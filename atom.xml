<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Unkai-Saiou</title>
  <subtitle>One demo website</subtitle>
  <link href="https://mizuki.mysqil.com/" rel="alternate" type="text/html"/>
  <link href="https://mizuki.mysqil.com/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://mizuki.mysqil.com/</id>
  <updated>2025-11-03T03:45:52.444Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>网络流 最大流</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-09-02-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-09-02-%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%80%E5%A4%A7%E6%B5%81/</id>
    <published>2025-09-02T00:00:00.000Z</published>
    <updated>2025-09-02T00:00:00.000Z</updated>
    <summary>网络流的最大流问题，EK算法和Dinic算法</summary>
    <content type="html"><![CDATA[<h3></h3>
<p>图论中的网络是一种特殊的有向图，与有向图不同的是网络存在容量、源点和汇点</p>
<ul>
<li>$E$ 边集中的每一条边 $(u,v)$ 都有一个被称为容量的权值 $c$</li>
<li>$V$ 点集中存在两个特殊点：源点 $s$ 和汇点 $t$</li>
</ul>
<p>在网络 $G=(V,E)$ 中，流是一个从边集到整数集的一个函数，$f(u,v)$ 表示边 $(u,v)$ 上的流量，$c(u,v)-f(u,v)$ 表示这条边的剩余容量</p>
<p>在网络中，合法的可行的流应该满足性质：</p>
<ul>
<li>容量限制：$0\le f(u,v)\le c(u,v)$</li>
<li>流量守恒：$\sum\limits_{(u,x)\in E} f(u,x)=\sum\limits_{(x,v)\in E} f(x,v),x\ne {s,t} $ ，形象化的说，一个普通点流入的容量等于流出的容量</li>
</ul>
<hr />
<h3>最大流问题</h3>
<p>我们希望在网络 $G=(V,E)$ 中找到合适的流 $f$ ，最大化这个网络的流量 $\lvert f\rvert =\sum\limits_{x\in V}f(s,x)-\sum\limits_{x\in V}f(x,s)$</p>
<p><strong>增广路：</strong> 一条从源点到汇点的路径，路径上所有边的剩余容量都大于 $0$</p>
<p><strong>残留网：</strong> 网络中所有结点和剩余容量大于 $0$ 的所有边构成的子图</p>
<h3>EK算法</h3>
<p>在建图时给每个有向边都构建一条反向边，容量为 $0$ ，目的是提供一条<strong>退流的路径</strong>，一旦前方的增广路无法连通可行流，那么就可以通过退流管道将增广路的部分流量退回</p>
<p>因为需要快速的定位反向边，所以采用<strong>链式前向星</strong>的方式存图</p>
<pre><code>struct edge{int v; LL c; int ne;};
edge e[M];
int h[210], idx = 1;//从2开始给边进行编号，0是哨兵

void add(int u, int v, LL c){
	e[++idx] = {v, c, h[u]};
	h[u] = idx;
}

for (int i = 1; i &lt;= m; i++){
	int u, v;
	LL c;
	cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;
	add(u, v, c);
	add(v, u, 0);
}
</code></pre>
<p>通过 BFS 找到一条增广路</p>
<p>类似贪心的扩展，每次只走到一个没有被访问过的节点</p>
<pre><code>int pre[210];//记录节点的前驱边
LL mf[210];//s到该点的流量上限

bool bfs(void){
	memset(mf, 0, sizeof mf);
	queue&lt;int&gt; q;
	q.push(s);
	mf[s] = 1e9;
	while (q.size()){
		int u = q.front();
		q.pop();
		for (int i = h[u]; i; i = e[i].ne){//枚举所有出边
			int v = e[i].v;
			if (mf[v] == 0 &amp;&amp; e[i].c){//只有这个邻点没有被访问过且有容量
				mf[v] = min(mf[u], e[i].c);
				pre[v] = i;
				q.push(v);
				if (v == t) return 1;//能走到汇点
			}
		}
	}
	return 0;//不能走到汇点，说明无可行流
}
</code></pre>
<p>每轮 BFS 都找到一条可行流，累加这些流的流量，然后构建残留网</p>
<pre><code>LL EK(void){
	LL flow = 0;
	while (bfs()){//存在可行流时
		int v=t;//从汇点出发
		while (v != s){//回溯到源点
			int i = pre[v];
			e[i].c -= mf[t];
			e[i^1].c += mf[t];//更新退流管道
			v = e[i^1].v;//走反向边
		}
		flow += mf[t];
	}
	return flow;//返回最大流
}
</code></pre>
<p><strong>总的时间复杂度上界为 $O(nm^2)$ 的级别，$n,m$ 分别为点数和边数，实际上会比这快得多</strong></p>
<h3>Dinic算法</h3>
<p>区别于 EK 算法每一轮只累加一条增广路的流量，我们可以先将点 BFS 分层然后通过 DFS 寻找多条增广路</p>
<pre><code>LL dfs(int u, LL mf){
	if (u == t) return mf;//如果到终点，返回流量
	LL res = 0;
	for (int i = cur[u]; i; i = e[i].ne){
		cur[u] = i;//当前弧优化
		int v = e[i].v;
		if (dep[v] == dep[u] + 1 &amp;&amp; e[i].w){//只有当下一个节点是下一层时才搜索
			LL f = dfs(v, min(mf, e[i].w));//流量限制
			e[i].w -= f;
			e[i ^ 1].w += f;//退流
			res += f;//累加当前流量
			mf -= f;
			if (mf == 0) break;//如果当前节点以及没有流量就立即返回
		}
	}
	if (res == 0) dep[u] = 0;//残枝优化
	return res;
}
</code></pre>
<p>其中的当前弧 <code>cur[u]</code> 表示节点 $u$ 在链式前向星中已经考虑过了哪些边，再次进入循环时就可以跳过这些边</p>
<p>残枝优化的意义时，如果当前节点的 <code>res</code> 为 $0$ ，这个节点就不会连通到汇点，所以在当前的残留网中就不需要考虑了</p>
<pre><code>LL dinic(){
	LL flow = 0;
	while (bfs()){
		memcpy(cur, h, sizeof h);//重置当前弧
		flow += dfs(s, 1e9);//累加可行流
	}
	return flow;
}
</code></pre>
<p><strong>时间复杂度为 $O(n^2m)$ 级别，在稠密图中的运行效率很优</strong></p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>FWT 快速沃尔什变换</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-11-fwt-%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-11-fwt-%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</id>
    <published>2025-08-11T00:00:00.000Z</published>
    <updated>2025-08-11T00:00:00.000Z</updated>
    <summary>FWT快速沃尔什变换应用计算方案数量</summary>
    <content type="html"><![CDATA[<p>FWT 快速沃尔什变换</p>
<p>对于整数数组进行位运算卷积的快速计算方式，和 FFT 类似的时间复杂度 $O(n\log n)$</p>
<hr />
<h3>引入</h3>
<p>位运算卷积：$C_i=\sum\limits_{i=j\otimes k} A_jB_k$ ，其中 $\otimes $ 表示某种位运算操作</p>
<p>正变换：通过 $A,B$ 序列计算 $f(A),f(B)$ ，然后进行运算 $f(C)=f(A)\cdot f(B)$</p>
<p>逆变换：通过 $f(C)$ 得到原序列 $C$</p>
<p><strong>定义 $f$ 函数的原则是需要满足 $f(A)=f(B)\cdot f(C)$</strong></p>
<hr />
<h3>或运算</h3>
<p>设 $k=i\cup j$ ，那么 $i,j$ 的二进制位为 $1$ 的位置一定也是 $k$ 的二进制为 $1$ 的位置的子集</p>
<p>定义 $A=a_0,a_1,\cdots a_n$ 表示序列 $A$ 的多项式函数的系数，$f(A)<em>i=\sum\limits</em>{i=i\cup j}A_j$ 则表示 $j$ 满足二进制中 $1$ 为 $i$ 的子集</p>
<p>检验：
$$
f(B)<em>i\cdot f(C)<em>i=\left(\sum\limits</em>{i=i\cup j}B_j\right)\cdot \left(\sum\limits</em>{i=i\cup k}C_k\right)=\sum\limits_{i=i\cup j}\sum\limits_{i=i\cup k}A_jB_k
$$
$$
=\sum\limits_{i=i\cup (j\cup k)}A_jB_k=f(c)_i
$$
枚举的时间复杂度是 $O(n^2)$ ，可以通过分治优化到 $O(n\log n)$</p>
<p>对形式化的多项式 $A(x)$ 而言，设它的最高次为 $2^n$ ，将其拆分为 $A_0,A_1$ 两个部分，最高次都为 $2^{n-1}$</p>
<p>有关或运算卷积的正变换计算可以被表示为：
$$
f(A)=merge\left[f(A_0),f(A_0)+f(A_1)\right]
$$
<strong>因为前半部分的 $A_0$ 一定不包含 $A_1$ 的最高位 $1$ ，所以 $f(A)$ 的前半部分只与 $f(A_0)$ 有关</strong></p>
<p>$merge$ 操作相当于把两个多项式直接连接起来</p>
<p>同样的有逆变换：
$$
f^{-1}(A)=merge\left[f^{-1}(A_0),f(A_1)^{-1}-f^{-1}(A_0)\right]
$$
采用<strong>迭代</strong>的方式，集成正逆变换</p>
<pre><code>void FWTOR(LL a[],int op){
	for (int d=2;d&lt;=(1&lt;&lt;m);d&lt;&lt;=1){//枚举分块数
		int k=d&gt;&gt;1;//分治
		for (int i=0;i&lt;(1&lt;&lt;m);i+=d){
			for (int j=0;j&lt;k;j++){//块内运算
				(a[i+j+k]+=a[i+j]*op)%=mod;
			}
		}
	}
}
</code></pre>
<hr />
<h3>与运算</h3>
<p>类比或运算可以得到相应运算：
$$
f(A)=merge\left[f(A_0)+f(A_1),f(A_0)\right]
$$
$$
f^{-1}(A)=merge\left[f^{-1}(A_0)-f^{-1}(A_0),f(A_1)\right]
$$</p>
<pre><code>void FWTAND(LL a[],int op){
	for (int d=2;d&lt;=(1&lt;&lt;m);d&lt;&lt;=1){
		int k=d&gt;&gt;1;
		for (int i=0;i&lt;(1&lt;&lt;m);i+=d){
			for (int j=0;j&lt;k;j++){
				(a[i+j]+=a[i+j+k]*op)%=mod;
			}
		}
	}
}
</code></pre>
<hr />
<h3>异或运算</h3>
<p>定义 $x\circ y=\mathrm{popcnt}(x\cap y)\ (\mathrm{mod}\ 2)$  表示 $x\cap y$ 中二进制 $1$ 的个数，所以有 $(x\circ y)\mathrm{xor}(x\circ z)=x\circ(y\ \mathrm{xor}\ z)$</p>
<p>设 $f(A)<em>i=\sum\limits</em>{i\circ j=0}A_j-\sum\limits_{i\circ j=1}A_j$ ，检验：
$$
f(B)<em>i\cdot f(C)<em>i=\left(\sum\limits</em>{i\circ j=0}B_j -\sum\limits</em>{i\circ j=1}B_j\right)\left(\sum\limits_{i\circ k=0}C_k -\sum\limits_{i\circ k=1}C_k\right)
$$
$$
=\left(\sum\limits_{i\circ j=0}B_j \sum\limits_{i\circ k=0}C_k+\sum\limits_{i\circ j=1}B_j \sum\limits_{i\circ k=1}C_k\right)-\left(\sum\limits_{i\circ j=0}B_j \sum\limits_{i\circ k=1}C_k+\sum\limits_{i\circ j=1}B_j \sum\limits_{i\circ k=0}C_k\right)
$$
$$
=\sum\limits_{(j\ \mathrm{xor}\ k)\circ i=0}B_jC_k-\sum\limits_{(j\ \mathrm{xor}\ k)\circ i=1}B_jC_k=f(c)_i
$$
正逆变换计算：
$$
f(A)=merge\left[ f(A_0)+f(A_1),f(A_0)-f(A_1) \right]
$$
$$
f^{-1}(A)=merge\left[ \frac{f^{-1}(A_0)+f^{-1}(A_1)}{2},\frac{f^{-1}(A_0)-f^{-1}(A_1)}{2}\right]
$$</p>
<pre><code>void FWTXOR(LL a[],int op){
	for (int d=2;d&lt;=(1&lt;&lt;m);d&lt;&lt;=1){
		int k=d&gt;&gt;1;
		for (int i=0;i&lt;(1&lt;&lt;m);i+=d){
			for (int j=0;j&lt;k;j++){
				(a[i+j]+=a[i+j+k])%=mod;
				(a[i+j+k]=a[i+j]-a[i+j+k]*2)%=mod;
				(a[i+j]*=op)%=mod;
				(a[i+j+k]*=op)%=mod;
			}
		}
	}
}
</code></pre>
<hr />
<p><strong>注意到的是，在函数执行过程中可能存在对负数取模的场景</strong></p>
<pre><code>(a[i+j+k]+=a[i+j]*op)%=mod;//op=-1时
</code></pre>
<p><strong>为了降低常数我们不在过程中取模而是统一在全部计算后再依次取正数模</strong></p>
<pre><code>for (int i=0;i&lt;n;i++)
    if (a[i]&lt;0) a[i]+=mod;
</code></pre>
<hr />
<h3>FMT 快速莫比乌斯变换优化</h3>
<p>莫比乌斯变换：定义 $f,g$ 是全集 $U$ 上的任意一个子集的函数，若：
$$
f(S)=\sum\limits_{S=S\cup T} g(T)
$$
则有：
$$
g(S)=\sum\limits_{S=S\cup T} (-1)^{\lvert S\rvert-\lvert T\rvert} f(T)
$$
证明：
$$
\begin{aligned}
\sum_{T \subseteq S} (-1)^{|S|-|T|} f(T)
&amp;= \sum_{T \subseteq S} (-1)^{|S|-|T|} \sum_{I \subseteq T} g(I) \
&amp;= \sum_{I \subseteq S} g(I) \sum_{I \subseteq T,, T \subseteq S} (-1)^{|S|-|T|} \
&amp;= \sum_{I \subseteq S} g(I) \sum_{T \subseteq S \setminus I} (-1)^{|S \setminus I| - |T|} \
&amp;= \sum_{I \subseteq S} g(I) \sum_{k=0}^{|S \setminus I|} \binom{|S \setminus I|}{k} (-1)^{|S \setminus I| - k} \
&amp;= \sum_{I \subseteq S} g(I) \cdot 0^{|S \setminus I|} \
&amp;= g(S)
\end{aligned}
$$
<strong>在某些场景下，我们可能并不需要逆变换后 $C$ 的每一项系数，而是只需要其中某一项次数为 $k$ 的系数</strong></p>
<p>对 $f(C)$ 进行逆变换的时间复杂度为 $O(n\log n)$ ，利用 FMT/容斥原理 可以在 $O(\log n)$ 的时间复杂度内计算出某一项的系数</p>
<pre><code>LL sum=0;
for (int i=0;i&lt;n;i++){
	if (__builtin_popcount(n-1-i)&amp;1) sum-=A[i];//这里的n-1是二进制全1的数
	else sum+=A[i];
	sum=(sum+mod)%mod;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>FFT 快速傅里叶变换</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-08-ftt-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-08-ftt-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</id>
    <published>2025-08-08T00:00:00.000Z</published>
    <updated>2025-08-08T00:00:00.000Z</updated>
    <summary>FFT快速傅里叶变换的应用，优化高精度乘法</summary>
    <content type="html"><![CDATA[<p>FTT 快速傅里叶变换</p>
<p>高效实现 DFT 离散傅里叶变换的一种手段，可以将两个 $n$ 次多项式相乘的时间复杂度优化到 $O(n\log n)$ 的算法</p>
<hr />
<p>**引理：**给定 $n$ 个点可以确定 $n-1$ 次函数曲线的系数和系数存在映射关系</p>
<p>设两个多项式分别为 $F(x),G(x)$</p>
<ul>
<li>
<p>通过这两个多项式的系数经过<strong>系数乘法</strong>可以计算出 $F(x)\cdot G(x)$ 的系数，基于单位圆划分出 $n$ 个点，通过计算得到的这 $n$ 个点值，我们就能<strong>唯一确定</strong>函数 $F(x)\cdot G(x)$</p>
</li>
<li>
<p>基于单位圆划分出 $n$ 个点，计算这两个多项式的这 $n$ 个点值，再利用<strong>点值乘法</strong>确定函数 $F(x)\cdot G(x)$</p>
</li>
</ul>
<hr />
<h3><strong>单位圆</strong></h3>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202508/3529184-20250808203357817-435762157.png" alt="image-20250807220538390" /></p>
<p>复平面的单位元圆上的点都可以被表示为：
$$
z=\cos \theta +i\sin \theta\  (0\le \theta &lt; 2\pi)
$$
把单元圆 $n$ 等分（$n=2^{b\in N^+}$），可以得到方程 $z^n=1$ 的 $n$ 个复数根 $\omega_n$ ，单位根为：
$$
\omega_n^k=\cos \frac{2\pi k}{n}+i\sin\frac{2\pi k}{n}
$$
满足性质有：$\omega _n^k\cdot \omega_n^m=\omega_n^{k+m},(\omega _n^k)^m=\omega _n^{km}$ ，周期性：$\omega _n^{k+n}=\omega _n^k$ ，对称性：$\omega _n^{k+\frac{n}{2}}=-\omega _n^k$ ，折半性：$\omega _n^{2k}=\omega _{\frac{n}{2}}^k$</p>
<h3>正变换</h3>
<p>通过多项式 $A(x)$ 的系数求点值，设系数为 $a_0,a_1,\cdots,a_{n-1}$ ，则 $A(x)$ 被表示为：
$$
A(x)=a_0+a_1x+a_2x^2+\cdots +a_{n-1} x^{n-1}
$$
将奇次项和偶次项分离后有：
$$
A(x)=(a_0+a_2x^2+\cdots +a_{n-2}x^{n-2})+(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2})x
$$
分别设 $A_0(x),A_1(x)$ 为：
$$
A_0(x)=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{\frac{n}{2}-1}
$$
$$
A_1(x)=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{\frac{n}{2}-1}
$$
$$
A(x)=A_0(x^2)+A_1(x^2)x
$$
将 $$x=\omega <em>n^k\ (k&lt;\frac{n}{2})$$ 代入得：
$$
A(\omega_n^k)=A_0(\omega_n^{2k})+A_1(\omega_n^{2k})\omega_n^k=A_0(\omega</em>\frac{n}{2}^{k})+A_1(\omega_\frac{n}{2}^{k})\omega_n^k
$$
同理代入 $$x=\omega <em>n^{k+\frac{n}{2}}\ (k&lt;\frac{n}{2})$$
$$
A(\omega_n^{k+\frac{n}{2}})=A_0(\omega_n^{2k+n})+A_1(\omega_n^{2k+n})\omega_n^{k+\frac{n}{2}}=A_0(\omega</em>\frac{n}{2}^{k})-A_1(\omega_\frac{n}{2}^{k})\omega_n^{k}
$$
在求出 $A_0(\omega _n^k),A_1(\omega _n^k)$ 后我们就能<strong>同时得到</strong> $A(\omega _n^k),A(\omega _n^{k+\frac{n}{2}})$ ，所以对 $A_0,A_1$ 分别进行递归求解</p>
<p>特别的，基于分治 FFT 处理的多项式长度只能是 $2^{b\in N^+}$ ，所以对于不是二整数次幂的形式，都需要补齐再计算</p>
<h3>逆变换</h3>
<p>通过多项式 $A(x)$ 的点值求系数，设代入 $\omega _n^0,\omega <em>n^1,\cdots,\omega <em>n^{n-1}$ 得到的点值为 $y_0,y_1,\cdots,y</em>{n-1}\ (y_i=\sum\limits</em>{j=0}^{n-1} a_j(\omega_n^i)^j)$</p>
<p>构造多项式 $B(x)$：
$$
B(x)=y_0+y_1x+\cdots+y_{n-1}x^{n-1}
$$
将单位根的倒数 $\omega <em>n^0,\omega <em>n^{-1},\cdots,\omega <em>n^{-(n-1)}$
$$
\omega <em>n^k=\cos \theta +i\sin \theta\
\frac{1}{\omega <em>n^k}=\frac{1}{\cos \theta +i\sin \theta}=\cos \theta -i\sin \theta=\cos (-\theta) +i\sin (-\theta)
$$
代入 $B(x)$ 得到新点值为 $z_0,z_1,\cdots,z</em>{n-1}$，其中：
$$
z_k=\sum\limits</em>{i=0}^{n-1} y_i(\omega_n^{-k})^i=\sum\limits</em>{i=0}^{n-1}\sum\limits</em>{j=0}^{n-1} a_j(\omega_n^i)^j(\omega_n^{-k})^i=\sum\limits</em>{j=0}^{n-1}a_j\sum\limits_{i=0}^{n-1}(\omega_n^{j-k})^i
$$
$$
\sum\limits_{i=0}^{n-1}(\omega_n^{j-k})^i=</p>
<p>\left{
\begin{array}{l}
\sum\limits_{i=0}^{n-1}1=n &amp; j=k\
(\omega_n^{j-k})^n=(\omega_n^n)^{j-k}=0 &amp; j\ne k
\end{array}
\right.
$$</p>
<p><strong>所以 $z_k=na_k$ ，通过 $\omega_n^{-k}$ 确定的点值逆变换后可以确定原函数的系数</strong></p>
<hr />
<h3>基于递归实现的 FFT</h3>
<pre><code>void FFT(vector&lt;complex&lt;double&gt;&gt; &amp;A,int n,int op){
	if (n==1) return;
	vector&lt;complex&lt;double&gt;&gt; A0(n/2),A1(n/2);
	for (int i=0;i&lt;n/2;i++)
		A0[i]=A[i*2],A1[i]=A[i*2+1];
	FFT(A0,n/2,op),FFT(A1,n/2,op);
	complex&lt;double&gt; w1({cos(2*PI/n),sin(2*PI/n)*op});
	complex&lt;double&gt; wk({1,0});
	for (int i=0;i&lt;n/2;i++){
		A[i]=A0[i]+A1[i]*wk;
		A[i+n/2]=A0[i]-A1[i]*wk;
		wk=wk*w1;
	}
}
</code></pre>
<p><code>op</code> 参数表示当前执行的是正变换还是逆变换，区别在于对 $\omega_n^k$ 的符号控制</p>
<hr />
<h3>基于迭代实现的 FFT</h3>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202508/3529184-20250808203408818-443987858.png" alt="image-20250808142932444" /></p>
<p>原序列分治到底层后变换的序列存在一个规律：</p>
<ul>
<li>每个数用二进制表示，将二进制翻转对称一下，就是最终那个位置的下标，例如 $a_0=001_2,a_4=100_2$ ，我们称这个变换为位逆序置换</li>
</ul>
<p>根据定义的方法，我们可以在 $O(n\log n)$ 的时间复杂度内求出每个数变换后的结果</p>
<p>事实上，还可以通过 $O(n)$ 的递推时间复杂度实现，设 $n=2^k$ ，$k$ 表示二进制数的长度</p>
<p>设 $R_x$ 为长度为 $k$ 的二进制数 $x$ 翻转后的结果，存在这样的递推关系：
$$
R_x=\frac{R_{\frac{x}{2}}}{2} +(x\ \mathrm{mod}\ 2)\times \frac{n}{2}
$$
从小到大求 $R_x$ ，$R_{\frac{x}{2}}$ 的值已知。把 $x$ <strong>除以二（右移一位）然后翻转再除以二</strong>，就得到了 $x$ 除开二进制个位之外其他位翻转的结果，再单独考虑二进制个位的影响，如果翻转前个位是 $1$ ，那么翻转后的最高位也为 $1$</p>
<pre><code>void change(vector&lt;complex&lt;double&gt;&gt; &amp;A,int n){
	vector&lt;int&gt; R(n,0);
	for (int i=0;i&lt;n;i++)
		R[i]=(R[i&gt;&gt;1]&gt;&gt;1)+((i&amp;1)?(n&gt;&gt;1):0);
	for (int i=0;i&lt;n;i++)
		if (i&lt;R[i]) swap(A[i],A[R[i]]);
}
</code></pre>
<p>利用位逆序变换得到后序列，然后自底向上合并</p>
<pre><code>void FFT(vector&lt;complex&lt;double&gt;&gt; &amp;A,int n,int op){
	change(A,n);
	for (int m=2;m&lt;=n;m&lt;&lt;=1){//枚举分治块的长度
		complex&lt;double&gt; w1({cos(2*PI/m),sin(2*PI/m)*op});
		for (int i=0;i&lt;n;i+=m){//枚举块的个数
			complex&lt;double&gt; wk({1,0});
			for (int j=0;j&lt;m/2;j++){//
				complex&lt;double&gt; x=A[i+j],y=A[i+j+m/2]*wk;
				A[i+j]=x+y;
				A[i+j+m/2]=x-y;
				wk=wk*w1;
			}
		}
	}
}
</code></pre>
<hr />
<h3>优化高精度乘法</h3>
<pre><code>void solve(){
	string sa,sb;
	cin&gt;&gt;sa&gt;&gt;sb;
	int n=sa.size(),m=sb.size();
	for (int i=n-1;i&gt;=0;i--) a[n-i-1]=sa[i]-'0';
	for (int i=m-1;i&gt;=0;i--) b[m-i-1]=sb[i]-'0';
	int nm=n+m;
	for (n=1;n&lt;=nm;n&lt;&lt;=1);
	FFT(a,n,1),FFT(b,n,1);
	for (int i=0;i&lt;n;i++) ab[i]=a[i]*b[i];
	FFT(ab,n,-1);
	vector&lt;int&gt; ans;
	for (int i=0,t=0;i&lt;n;i++){
		t+=(ab[i].real()/n+0.5);
		ans.push_back(t%10);
		t/=10;
	}
	while (ans.size()&gt;1&amp;&amp;ans.back()==0) ans.pop_back();
	for (int i=ans.size()-1;i&gt;=0;i--) cout&lt;&lt;ans[i];
}
</code></pre>
<p>将十进制数看作一个 $x=10$ 的函数 $A(x)$ ，每个系数 $a_{i}$ 表示第 $i+1$ 位上的数</p>
<p>同样的，将读入的两个数 $a,b$ 转化为数组存储后利用 FFT 计算出点值，然后通过点值乘法计算 $a\times b$ 映射的点值</p>
<p><strong>再通过 FFT 逆变换计算出系数，最后按位取模得到拆分下来的十进制的每一位</strong></p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>威尔逊定理、裴蜀定理</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-27-%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-27-%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</id>
    <published>2025-07-27T00:00:00.000Z</published>
    <updated>2025-07-27T00:00:00.000Z</updated>
    <summary>威尔逊定理和裴蜀定理的基本概念与应用</summary>
    <content type="html"><![CDATA[<h3>威尔逊定理</h3>
<p>判定整数 $p$ 为质数的充分必要条件是：
$$
(p-1)!\equiv -1 (\mathrm{mod}\ p)
$$
<strong>充分性证明：当 $p$ 不为质数时</strong></p>
<ul>
<li>
<p>$p$ 可以被表示为完全平方数，即 $p=k^2$</p>
<p>当 $k&gt;2$ 时，显然有 $2k&lt;p=k^2$，则 $(p-1)!=1\times2\times\cdots\times k\times \cdots \times 2k\times\cdots \times (p-1)$</p>
<p>提出 $k,2k$ 得 $(p-1)!=k^2\times \alpha=p\times \alpha$ ，那么 $(p-1)!\equiv 0(\mathrm{mod}\ p)$</p>
</li>
<li>
<p>$p$ 不是完全平方数，即 $p=a\times b\ (a\ne b)$</p>
<p>令 $1&lt;a&lt;b&lt;p$ ，则 $(p-1)!=1\times2\times\cdots\times a\times \cdots \times b\times\cdots \times (p-1)$</p>
<p>提出 $a,b$ 得 $(p-1)!=a\times b\times \alpha=p\times \alpha$ ，那么 $(p-1)!\equiv 0(\mathrm{mod\ }p)$</p>
</li>
</ul>
<p><strong>必要性证明：当 $p$ 为质数</strong></p>
<p>质数 $p$ 的简化剩余系为 ${1,2,\cdots,(p-1)}$ ，模意义下的逆元形式为 $ax\equiv 1(\mathrm{mod\ }p)$</p>
<p>**引理：**对于模 $m$ 的简化剩余系中每个元素 $a$ 都存在唯一元素 $x$（<strong>也在同一简化剩余系内</strong>） 满足 $ax\equiv 1(\mathrm{mod\ }m)$</p>
<ul>
<li>
<p>当 $a=x$ 时，有 $x^2 \equiv 1(\mathrm{mod\ }p)$ ，分解得到 $(x-1)(x+1)\equiv 0(\mathrm{mod\ }p)$ 。则 $a=x=1,(p-1)$</p>
</li>
<li>
<p>当 $a\ne x$ 时，满足 $ax\equiv 1(\mathrm{mod\ }p)$ 的 $(a,x)$ 从 $[2,p-2]$ 的集合中取得，必然存在 $\frac{p-3}{2}$ 对不同的 $(a,x)$ 使得同余式成立</p>
<p>即 $(p-2)!\equiv 1(\mathrm{mod\ }p)$</p>
</li>
</ul>
<p>$(p-2)!\equiv 1 (\mathrm{mod}\ p)$ 在同余式两侧都乘上 $p-1$ 后，有 $(p-1)!\equiv 1(\mathrm{mod\ }p)$ ，证毕</p>
<p><strong>推论：</strong></p>
<ul>
<li>若正整数 $p$ 为质数，则 $(p-1)!+1\equiv 0(\mathrm{mod\ }p)$</li>
<li>若正整数 $p$ 为大于 $4$ 的合数，则 $(p-1)!\equiv 0(\mathrm{mod\ }p)$</li>
</ul>
<h3>裴蜀定理</h3>
<p>对于给定的整数 $a,b$ 一定存在整数 $x,y$ 满足等式
$$
ax+by=\mathrm{gcd}(a,b)
$$
<strong>证明：</strong></p>
<p>设正整数 $x,y,a,b$ 有 $ax+by$ ，设 $x=x_0,y=y_0$ 时有等式 $ax+by=s$ ，其中 $s$ 为满足等式的<strong>最小正整数</strong></p>
<ul>
<li>
<p>显然存在整除关系：$\mathrm{gcd}(a,b)\mid ax_0\ ,\ \mathrm{gcd}(a,b)\mid by_0$，则 $\mathrm{gcd}(a,b)\mid s$ 也成立</p>
</li>
<li>
<p>设 $a=qs+r(0\le r&lt;s)$  即 $a$ 通过 $s$ 的除法余数表示，那么有：
$$
r=a-qs=a-q(ax_0+by_0)\
\implies r=a(1-qx_0)+b(-qy_0)
$$
因为 $q$ 为整数，所以 $(1-qx_0),(-qy_0)$ 也都为整数，那么对于相同的 $a,b$ 上述等式可以被改写为
$$
r=a(1-qx_0)+b(-qy_0)=ax_1+by_1
$$
那么 $r$ 也为形如 $ax+by=s$ 的数，因为 $s$ 是最小正整数解，那么 $r=0$</p>
<p>所以 $a=qs$ ，则 $s\mid a$ ，同理得到 $s\mid b$ ，故 $s\mid \mathrm{gcd}(a,b)$</p>
</li>
</ul>
<p>$\mathrm{gcd}(a,b)\mid s,s\mid \mathrm{gcd}(a,b)$ 同时成立当且仅当 $s= \mathrm{gcd}(a,b)$ ，证毕</p>
<p>特别的 ，当 $a,b$ 有负数时，计算的 $\mathrm{gcd}(a,b)$ 也为负数，<strong>但由于正负性不改变解，所以可以直接取绝对值计算</strong></p>
<p><strong>推广定理：</strong></p>
<ul>
<li>对于给定的整数 $a,b$ 一定存在整数 $x,y$ 满足 $ax+by=\mathrm{gcd}(a,b)\times n$ ，$n$ 为正整数</li>
<li>对于给定的整数集合 $A$ ，一定存在整数 $X$ 集合满足 $\sum A_iX_i=\mathrm{gcd}(A_1,A_2,\cdots,A_n)$</li>
</ul>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>同余类、欧拉降幂</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-23-%E5%90%8C%E4%BD%99%E7%B1%BB%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-23-%E5%90%8C%E4%BD%99%E7%B1%BB%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/</id>
    <published>2025-07-23T00:00:00.000Z</published>
    <updated>2025-07-23T00:00:00.000Z</updated>
    <summary>同余类和欧拉降幂的基本概念与应用</summary>
    <content type="html"><![CDATA[<h3>同余类</h3>
<p>给定一个正整数 $n$ ，将所有整数依据模 $n$ 的余数 $r\in[0,n-1]$ 分为 $n$ 类，其中每一类都可以被表示为 $C_r=nx+r$ ，一个 $C_r$ 构成的一个集合是模 $n$ 的一个同余类</p>
<h3>完全剩余系</h3>
<p>给定一个正整数 $n$ ，有 $n$ 个不同的模 $n$ 的同余类，从这 $n$ 个同余类中各选出一个元素共计 $n$ 个数，这些数构成的一个集合为模 $n$ 的一个完全剩余系。显然对于正整数 $n$ 一定存在一个完全剩余系是 $Z_n=[0,n-1]$ ，该剩余系为简单完全剩余系。同理，对剩余系中任意元素加上 $n$ 的整数倍后得到的集合仍然为模 $n$ 的一个完全剩余系</p>
<h3>简化剩余系</h3>
<p>给定一个正整数 $n$ ，有 $\varphi(n)$ 个不同的模 $n$ 的余数 $r$ 与 $n$ 互质的同余类，在这 $\varphi(n)$ 个同余类中各选出一个元素共计 $\varphi(n)$ 个数，这些数构成的一个集合是模 $n$ 的一个简化剩余系。其中 $\varphi(n)$ 为 $n$ 的欧拉函数
$$
\varphi(n)=n\times \prod_{i=1}^s \frac{p_i-1}{p_i}
$$</p>
<h3>欧拉定理</h3>
<p>若 ${\rm{gcd}}(a,m)=1$，则 $a^{\varphi(m)} \equiv 1({\rm{mod}}\ m)$</p>
<p>简单证明：</p>
<p>设 ${r_1,r_2,\cdots ,r_{\varphi(m)} }$ 是一个模 $m$ 的简化剩余系，则 ${ar_1,ar_2,\cdots,ar_{\varphi(m)} }$ 也是模 $m$ 的一个简化剩余系，所以有
$$
\prod_{i=1}^{\varphi(m)} r_i\equiv \prod_{i=1}^{\varphi(m)} ar_i \equiv a^{\varphi(m)}\prod_{i=1}^{\varphi(m)} r_i ({\rm{mod }}\ m)
$$
同余式两侧约去 $\prod_{i=1}^{\varphi(m)} r_i$ 后得
$$
a^{\varphi(m)} \equiv 1({\rm{mod}}\ m)
$$
当 $m$ 为质数时 $\varphi(m)=m-1$ ，得到费马小定理 $a^{m-1}\equiv 1({\rm{mod}}\ m)$</p>
<h3>扩展欧拉定理</h3>
<p>$$
a^b=\left{ \begin{array}{l}
a^{b\ {\rm{mod}}\ \varphi(m)} &amp; {\rm{gcd}}(a,m)=1 &amp;({\rm{mod}}\ m)
\
a^b&amp;b&lt;\varphi(m),{\rm{gcd}}(a,m)\ne1 &amp;({\rm{mod}}\ m)
\
a^{b\ {\rm{mod}}\ \varphi(m)+\varphi(m)} &amp;b\ge\varphi(m),{\rm{gcd}}(a,m)\ne1&amp;({\rm{mod}}\ m)
\end{array} \right.
$$</p>
<p>计算 $a^b$ 时，若 $b$ 较小，直接跑一遍快速幂即可，否则先用扩展欧拉定理进行降幂再跑快速幂</p>
<p><strong>对于单独的 $b$ 来说，利用试除法比筛法更加优秀</strong></p>
<pre><code>LL get_phi(LL n){
	LL res=n;
	for (LL i=2;i*i&lt;=n;i++){
		if (n%i==0){
			res=res*(i-1)/i;
			while (n%i==0)
				n/=i;
		}
	}
	if (n&gt;1) res=res*(n-1)/n;
	return res;
}
</code></pre>
<p><strong>对 $b$ 进行降幂操作，因为 $a^{\varphi(m)} \equiv 1\to a^{b\ {\rm{mod}}\ \varphi(m)}\equiv a^{b\ {\rm{mod}}\ \varphi(m)+\varphi(m)}({\rm{mod}}\ m)$ ，所以不需要单独判断</strong></p>
<pre><code>LL depow(LL phi,string b){
	LL res=0;
	bool f=0;//判断b和phi_m的大小关系
	for (auto c:b){
		res=res*10+(c-'0');
		if (res&gt;=phi) f=1,res%=phi;
	}
	if (f) res+=phi;//如果b&gt;phi_m则需要加上phi_m
	return res;
}
</code></pre>
<p>以洛谷P5091为例：https://www.luogu.com.cn/problem/P5091、</p>
<pre><code>LL ksm(LL a,LL b,LL p){
	LL res=1;
	while (b){
		if (b&amp;1) res=res*a%p;
		a=a*a%p;
		b&gt;&gt;=1;
	}
	return res;
}

LL get_phi(LL n){
	LL res=n;
	for (LL i=2;i*i&lt;=n;i++){
		if (n%i==0){
			res=res*(i-1)/i;
			while (n%i==0)
				n/=i;
		}
	}
	if (n&gt;1) res=res*(n-1)/n;
	return res;
}

LL depow(LL phi,string b){
	LL res=0;
	bool f=0;
	for (auto c:b){
		res=res*10+(c-'0');
		if (res&gt;=phi) f=1,res%=phi;
	}
	if (f) res+=phi;
	return res;
}

void solve(){
	LL a,m;
	string b;
	cin&gt;&gt;a&gt;&gt;m&gt;&gt;b;
	cout&lt;&lt;ksm(a,depow(get_phi(m),b),m)&lt;&lt;endl;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>Tarjan_算法处理_缩点、割点、割边</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-07-14-tarjan%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86-%E7%BC%A9%E7%82%B9%E5%89%B2%E7%82%B9%E5%89%B2%E8%BE%B9/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-07-14-tarjan%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86-%E7%BC%A9%E7%82%B9%E5%89%B2%E7%82%B9%E5%89%B2%E8%BE%B9/</id>
    <published>2025-07-14T00:00:00.000Z</published>
    <updated>2025-07-14T00:00:00.000Z</updated>
    <summary>强连通分量简化有向图的方法</summary>
    <content type="html"><![CDATA[<p>Tarjan 算法处理 缩点、割点、割边</p>
<h3>强连通分量SCC缩点</h3>
<p>对<strong>有向图</strong>进行简化操作，将图中的强连通分量合并为一个节点</p>
<p>合并后的节点具有合并前所有节点的权值贡献且不会重复，对于边的处理<strong>当且仅当 SCC 内部有出入边时才映射</strong></p>
<p>例：洛谷P3387  https://www.luogu.com.cn/problem/P3387</p>
<pre><code>const int N=1e4+10;

vector&lt;int&gt; e[N];
vector&lt;int&gt; stk;
bool instk[N];
int dfn[N],low[N],idx;
int scc[N],nw[N],cnt;
vector&lt;int&gt; ne[N];
int dp[N];
int w[N];

void tarjan(int x){
	dfn[x]=low[x]=++idx;
	stk.push_back(x);
	instk[x]=1;
	
	for (auto v:e[x]){
		if (!dfn[v]){
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}else if (instk[v])
			low[x]=min(low[x],dfn[v]);
	}
	
	if (low[x]==dfn[x]){
		int t;
		cnt++;
		do{
			t=stk.back();
			stk.pop_back();
			instk[t]=0;
			scc[t]=cnt;
			nw[cnt]+=w[t];//计算合并后权值
		}while (t!=x);
	}
}

void solve(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for (int i=1;i&lt;=n;i++) cin&gt;&gt;w[i];
	for (int i=1;i&lt;=m;i++){
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		e[u].push_back(v);
	}
	
	for (int i=1;i&lt;=n;i++)
		if (!dfn[i]) tarjan(i);
		
	for (int i=1;i&lt;=n;i++){
		for (auto v:e[i])
			if (scc[i]!=scc[v])
				ne[scc[i]].push_back(scc[v]);
		dp[i]=nw[i];
	}
	
	int ans=0;
	for (int i=cnt;i&gt;=1;i--){
		for (auto v:ne[i])
			dp[v]=max(dp[v],dp[i]+nw[v]);
		ans=max(ans,dp[i]);
	}
	cout&lt;&lt;ans;
}
</code></pre>
<p>首先遍历这张图，Tarjan算法处理出所有的强连通分量：<code>scc[N]</code> ，同时，计算合并节点的总权值 <code>nw[N]</code></p>
<p>然后对边进行映射：</p>
<pre><code>for (int i=1;i&lt;=n;i++)
	for (auto v:e[i])
		if (scc[i]!=scc[v])//当且仅当这条边不在SCC内才映射
			ne[scc[i]].push_back(scc[v]);
</code></pre>
<p>最后计算简化后的图上最大权值路径，因为我们对 SCC 编号是<strong>拓扑逆序</strong>的，所以最后逆向遍历这张图</p>
<p>采用类似 DP 的方式计算最大权值</p>
<pre><code>int ans=0;
for (int i=cnt;i&gt;=1;i--){
	for (auto v:ne[i])
		dp[v]=max(dp[v],dp[i]+nw[v]);//更新权值
	ans=max(ans,dp[i]);
}
</code></pre>
<h3>割点</h3>
<p>在一张无向图中，删去<strong>某个顶点</strong>后图中的极大连通分量数增加，那么该点为一个割点</p>
<p>判定法则：如果节点 $x$ <strong>不是根节点</strong>，当且仅当搜索树上存在<strong>一个</strong> $x$ 的子节点 $y$ 满足 ${\rm{low}}<em>y\ge {\rm{dfn}}<em>x$ 时 $x$ 为割点。如果 $x$ <strong>是根节点</strong>，当且仅当搜索树上<strong>至少存在两个</strong>子节点 $y_1,y_2$ 满足 ${\rm{low}}</em>{y</em>{1,2}}\ge {\rm{dfn}}_x$ 时 $x$ 为割点</p>
<pre><code>vector&lt;int&gt; e[N];
int dfn[N],low[N],idx;
int cut[N],root;

void tarjan(int x){
	dfn[x]=low[x]=++idx;
	int son=0;
	for (auto v:e[x]){
		if (!dfn[v]){
			tarjan(v);
			low[x]=min(low[x],low[v]);
			if (low[v]&gt;=dfn[x]){//判断是否为割点的必要条件
				son++;//x的子树+1
				if (x!=root||son&gt;1)//判断根节点的情况
					cut[x]=1;
			}
		}else
			low[x]=min(low[x],dfn[v]);//直接更新
	}
}

void solve(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for (int i=1;i&lt;=m;i++){
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for (int i=1;i&lt;=n;i++){
		if (!dfn[i]){
			root=i;//指定当前连通分量的根节点
			tarjan(i);
		} 
	}
	int sum=0;
	for (int i=1;i&lt;=n;i++) sum+=cut[i];
	cout&lt;&lt;sum&lt;&lt;endl;
	for (int i=1;i&lt;=n;i++)
		if (cut[i]) cout&lt;&lt;i&lt;&lt;' ';
}
</code></pre>
<p>特别的，在无向图中不存在横叉边，所以不用考虑 $v$ 是否在栈内**（任何非树边都必然是后向边）**因此可以直接用 ${\rm{dfn_v}}$ 更新 ${\rm{low}}_x$</p>
<h3>割边（桥）</h3>
<p>在一张无向图中，删去<strong>某条边</strong>后图中的极大连通分量数增加，那么该点为一个割边或桥</p>
<p>判定法则：当搜索树上存在 $x$ 的一个子节点 $y$ 满足 ${\rm{low}}_y&gt;{\rm{dfn}}_x$ 时，这条边为割边</p>
<pre><code>struct edge{int u,v;};
vector&lt;edge&gt; e;
vector&lt;int&gt; h[N];
int dfn[N],low[N],idx;
vector&lt;edge&gt; bri;

void tarjan(int x,int ine){
	dfn[x]=low[x]=++idx;
	for (auto ote:h[x]){
		int v=e[ote].v;
		if (!dfn[v]){
			tarjan(v,ote);
			low[x]=min(low[x],low[v]);
			if (low[v]&gt;dfn[x])
				bri.push_back(e[ote]);
		}else if (ote!=(ine^1))
			low[x]=min(low[x],dfn[v]);
	}
}


void solve(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for (int i=1;i&lt;=m;i++){
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		e.push_back({u,v});
		h[u].push_back(e.size()-1);
		e.push_back({v,u});
		h[v].push_back(e.size()-1);
	}
	
	for (int i=1;i&lt;=n;i++)
		if (!dfn[i]) tarjan(i,0);
	
	auto cmp=[](edge x,edge y){
		if (x.u!=y.u) return x.u&lt;y.u;
		return x.v&lt;y.v;
	};
	
	sort(bri.begin(),bri.end(),cmp);
	for (auto e:bri){
		if (e.u&lt;e.v)
			cout&lt;&lt;e.u&lt;&lt;' '&lt;&lt;e.v&lt;&lt;endl;
		else
			cout&lt;&lt;e.v&lt;&lt;' '&lt;&lt;e.u&lt;&lt;endl;
	}
}
</code></pre>
<p>因为要处理边，所以不采用邻接点的方式存边，而是直接记录边集</p>
<pre><code>struct edge{int u,v;};
vector&lt;edge&gt; e;
</code></pre>
<p>而且图是一张无向图，对边进行编号时我们按照连续奇偶序号编号</p>
<pre><code>vector&lt;int&gt; h[N];//节点的出边
e.push_back({u,v});
h[u].push_back(e.size()-1);//按照边加入的顺序编号，从0开始
e.push_back({v,u});
h[v].push_back(e.size()-1);//反向存边
</code></pre>
<p>Tarjan算法实现时，通过 <code>h[N]</code> 记录的出边编号建立搜索树</p>
<pre><code>for (auto ote:h[x]){
	int v=e[ote].v;
	if (!dfn[v]){
		tarjan(v,ote);
		low[x]=min(low[x],low[v]);
		if (low[v]&gt;dfn[x])
			bri.push_back(e[ote]);
	}else if (ote!=(ine^1))
		low[x]=min(low[x],dfn[v]);
}
</code></pre>
<p>因为对同一条边，正反编号时连续的奇偶，那么可以通过异或运算确定两条边是否为同一条无向边</p>
<pre><code>else if (ote!=(ine^1)) //当这条出边ote边和入边ine不是同一条边时才更新
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>筛法求约数个数、约数和定理</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-05-21-%E7%AD%9B%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-05-21-%E7%AD%9B%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/</id>
    <published>2025-05-21T00:00:00.000Z</published>
    <updated>2025-05-21T00:00:00.000Z</updated>
    <summary>约数个数的计算以及相关定理</summary>
    <content type="html"><![CDATA[<h3>约数</h3>
<p>定义：$a|b$ 表示 $a$ 整除于 $b$ （$b$ 能被 $a$ 整除），$b$ 为 $a$ 的倍数，$a$ 为 $b$ 的约数</p>
<p>规定 <strong>$0$ 是所有非 $0$ 整数的倍数</strong>，且对于非 $0$ 整数 $b$ ，$b$ 的约数只有<strong>有限个</strong></p>
<p>对于非 $0$ 整数 $b$ ，$\pm1,\pm b$ 是 $b$ 的平凡约数（当 $b=\pm1$ 时，$b$ 只有两个平凡约数），$b$ 的其他约数称为真约数（非平凡约数）</p>
<p>满足性质如下：</p>
<ul>
<li>整数 $b\ne0$，给定的 $d$ 在遍历 $b$ 的全体约数时，$\frac{b}{d}$ 也遍历 $b$ 的全体约数</li>
<li>整数 $b&gt;0$，给定的 $d$ 在遍历 $b$ 的全体正约数时，$\frac{b}{d}$ 也遍历 $b$ 的全体正约数</li>
</ul>
<p><strong>一般讨论中，我们约定的约数总是指正约数</strong></p>
<h3>约数个数定理</h3>
<p>对于整数 $n&gt;1$ ，根据唯一分解定理其可以被分解为若干个质因子的连乘积，表示为
$$
n=\prod_{i=1}^{s} p_i^{\alpha <em>i}=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdots p_s^{\alpha_s}
$$
那么它的约数个数 $d(n)$ 可以通过下面的表达式得出
$$
d(n)=\prod</em>{i=1}^s (\alpha_i+1)
$$
简单证明如下：</p>
<p>$p_i^{\alpha_i}$ 的因子有 $p_1^0,p_i^1,\cdots,p_i^{\alpha_i}$ 共计 $\alpha_i+1$ 个，递推地计算 $p_{i+1}^{\alpha_{i+1}}$ 及所有项，根据乘法原理得出 $d(n)=\prod_{i=1}^s (\alpha_i+1)$</p>
<p>（若 $p_i^a,p_j^b$ 都是 $n$ 的因子，那么 $p_i^a*p_j^b$ 也是 $n$ 的因子）</p>
<h3>线性筛法求约数个数</h3>
<p>筛除合数时，分别考虑两种情况</p>
<ul>
<li>
<p>枚举的 $i$ 能被 $p_j$ 整除，则 $p_j$ 一定是 $m$ 的最小质因子，于是递推积累最小质因子的次数 $\alpha_m=\alpha_i+1$</p>
<p>因为 $d(i)=(\alpha_i+1)<em>\cdots,d(m)=(\alpha_m+1)</em>\cdots$ 所以 $d(m)$ 由下式计算得出
$$
d(m)=d(i)<em>\frac{1}{\alpha_m}</em>(\alpha_m+1)
$$</p>
</li>
<li>
<p>若 $i$ 不能被 $p_j$ 整除，则 $i$ 不包含质因子 $p_j$，那么 $\alpha_m=1,d(m)=d(i)<em>(\alpha_m+1)=2</em>d(i)$</p>
</li>
</ul>
<pre><code>int p[N],cnt;
bool vis[N];
int a[N],d[N];//a用来记录i的质因子的次数alpha_i，d用来记录i的约数个数

void get_d(int n){
	d[1]=1;//定义1的约数个数为1
	for (int i=2;i&lt;=n;i++){
		if (!vis[i]){//如果当前i为质数
			p[++cnt]=i;//存进p数组
			a[i]=1;//质数的最小质因子是它本身，且次数为1
			d[i]=2;//规定质数的约数个数为2
		}
		for (int j=1;i*p[j]&lt;=n;j++){//筛除以i为最小质因子的合数
			int m=i*p[j];
			vis[m]=1;//标记合数
			if (i%p[j]==0){//确定只被最小质因子筛除
				a[m]=a[i]+1;
				d[m]=d[i]/a[m]*(a[m]+1);
				break;
			}else{
				a[m]=1;
				d[m]=d[i]*2;
			}
		}
	}
}
</code></pre>
<h3>约数和定理</h3>
<p>有 $n=\prod_{i=1}^sp_i^{\alpha_i}$ ，记 $n$ 的约数和为 $f(n)$ ，满足
$$
f(n)=\prod_{i=1}^s \sum_{j=0}^{\alpha_i} p_i^j
$$
简单证明如下：</p>
<p>通过约数个数定理可知，$n$ 的任意一个约数都是在每一个质因子 $p_1^{\alpha_1},p_2^{\alpha_2},\cdots,p_s^{\alpha_s}$ 中，选出这个质因子 $p_i^{\alpha_i}$ 的任意一个约数乘法组合而成</p>
<p>那么，不同的选法共有 $\prod_{i=1}^s (\alpha_i+1)$ 种，即约数个数</p>
<p>那么，它们的和即为
$$
(p_1^0+p_1^1+\cdots+p_1^{\alpha_1})\times(p_2^0+p_1^2+\cdots+p_2^{\alpha_2})\times\cdots\times(p_s^0+p_s^1+\cdots+p_s^{\alpha_s})
$$
可以看作分别计算出了每个质因子的约数的每种情况，再相加</p>
<h3>线性筛法求约数和</h3>
<p>需要记录每个 $i$ 的最小质因子贡献的累加和，记为 $g_i$，其中 $p_{\gamma}$ 表示 $i$ 的最小质因子
$$
g_i=\sum_{i=0}^{\alpha_i} p_{\gamma}^i
$$
筛除合数时，分别考虑两种情况</p>
<ul>
<li>
<p>枚举的 $i$ 能被 $p_j$ 整除，则 $p_j$ 一定是 $m$ 的最小质因子，分别计算 $g_i,g_m$</p>
<p>$$
g_i=\sum_{i=0}^{\alpha_j}p_j^i \ \ ,\ \  g_m=\sum_{i=0}^{\alpha_j+1}p_j^i=g_i<em>p_j+p_j^0
$$
那么就能从 $f_i$ 递推到 $f_m$
$$
f_i=g_i</em>\prod_{j}^{j\ne i} g_j\ \ ,\ \ f_m=g_m*\prod_j^{j\ne i} g_j=\frac{f_i}{g_i}*g_m
$$</p>
</li>
<li>
<p>若 $i$ 不能被 $p_j$ 整除，则 $i$ 不包含质因子 $p_j$
$$
g_m=1+p_j\ \ ,\ \ f_m=g_m*f_i
$$</p>
</li>
</ul>
<pre><code>int p[N],cnt;
bool vis[N];
int g[N],f[N];//g记录i的最小质因子贡献的累加和，f表示i的约数和

void get_f(int n){
	g[1]=f[1]=1;
	for (int i=2;i&lt;=n;i++){
		if (!vis[i]){
			p[++cnt]=i;
			g[i]=f[i]=i+1;
		}
		for (int j=1;i*p[j]&lt;=n;j++){
			int m=i*p[j];
			vis[m]=1;
			if (i%p[j]==0){
				g[m]=g[i]*p[j]+1;
				f[m]=f[i]/g[i]*g[m];
				break;
			}else{
				g[m]=p[j]+1;
				f[m]=f[i]*g[m];
			}
		}
	}
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>树的重心与直径</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-04-27-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%E4%B8%8E%E7%9B%B4%E5%BE%84/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-04-27-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%E4%B8%8E%E7%9B%B4%E5%BE%84/</id>
    <published>2025-04-27T00:00:00.000Z</published>
    <updated>2025-04-27T00:00:00.000Z</updated>
    <summary>动态规划计算树的某些性质</summary>
    <content type="html"><![CDATA[<p>树的重心与直径</p>
<h2>树的重心</h2>
<p>有以下三种定义方式：</p>
<ul>
<li>以某点为根，最大子树的节点数最小，该点为重心</li>
<li>以某点为根，所有子树的节点数不超过总节点数的一半，该点为重心</li>
<li>以某点为根，所有节点到这个根边数和最小，该点为重心</li>
</ul>
<p>也存在以下这些性质：</p>
<ul>
<li>一棵树最多有两个重心，且这两个重心一定相邻</li>
<li>给这棵树增加或减少一个叶子节点，转移后的重心最多只会移动一条边</li>
<li>将两棵树合并后，新的重心一定在原来的两个重心的路径上</li>
<li>如果树的边权都为正，那么所有节点到重心的边权和最小，且与边权的分布无关</li>
</ul>
<hr />
<p>求树的重心，可用树形DP的方式计算</p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202504/3529184-20250421173745338-1381611845.png" alt="" /></p>
<p>计算重心的过程中，任取当前遍历到的节点 $u$，如果 $u$ 为重心，那么可以把以 $u$ 为根的子树连通块分为两类：</p>
<p>$u$ 的子树和 $u$ 之上的连通块，例如在上图中以 $6$ 为根节点，则第一类为连通块 ${1,2,3,4,5}$ 第二类为 ${7},{8},{9}$</p>
<p><strong>根据树的重心的第一个定义，我们需要使得 $u$ 节点的最大子树的节点数与 $u$ 节点之上的连通块的节点数的最大值最小</strong></p>
<p>设 $sum$ 以 $u$ 节点为根的子树的节点数之和，$size$ 为 $u$ 节点最大子树的节点树</p>
<p>那么 $u$ 之上的连通块的节点数为 $n-size$，$n$ 为所有节点总数，我们需要使这样一个表达式最小，即计算：
$$
{\rm{min}_{u=1}^n}[{\rm{max}}(size_u,n-sum_u)]
$$</p>
<pre><code>int dfs(int x,int p){
	int size=0;//初始化
	int sum=1;//以u为根的节点总数包括根节点
	for (auto v:e[x]){
		if (v==p) continue;
		int res=dfs(v,x);//
		size=max(size,res);//回溯计算最大子树的节点数
		sum+=res;//回溯计算以u为根的节点总数
	}
	if (ans&gt;max(size,n-sum)){
		ans=max(size,n-sum);
		st.clear();
		st.push_back(x);
	}else if (ans==max(size,n-sum))
		st.push_back(x);//如果有多个重心则记录
	return sum;//返回以这个节点为根的节点总数
}
</code></pre>
<p>每次回溯时，都上传 $sum$ ，即向父节点转移以某个子节点 $u$ 为根的节点总数</p>
<p>同时在父节点上计算他的最大子树的节点数，即 <code>size=max(size,dfs(v,x))</code></p>
<h2>树的直径</h2>
<p>定义：树上任意两点之间最长的简单路径为树的直径</p>
<p>有两种求法为：两次DFS，树形DP</p>
<p><strong>其中 DFS 的方法只能处理非负权树，树形DP的方法无法得到直径路径上的信息（只能得到直径的值）</strong></p>
<p>存在以下性质：</p>
<ul>
<li>直径两端点一定是两个叶子节点</li>
<li>对于两棵树，他们的直径分别被表示为 ${\rm{dis}}(x,y),{\rm{dis}}(u,v)$ ，用一条边将这两棵树连接后新树的直径一定是 ${x,y,u,v}$ 其中的两个点形成的简单路径</li>
<li>对于一棵树的，在他的某一点上新接一个叶子节点，<strong>那么最多只会改变树的直径的一个端点</strong></li>
<li>如果一棵树有多个直径，那么这些直径一定会有一部分在中间部分重合 （公共点或公共路径）</li>
</ul>
<hr />
<h3>两次DFS：</h3>
<p>第一次DFS找到离出发点最远的节点 $c$ ，第二次DFS从 $c$ 出发再到离 $c$ 最远的节点，他们之间的简单路径距离即为树的直径</p>
<pre><code>void dfs(int x,int p){
	for (auto it:e[x]){
		if (it.v==p) continue;
		d[it.v]=d[x]+it.w;//记录路径长度
		if (d[it.v]&gt;d[c]) c=it.v;//更新最远点
		dfs(it.v,x);
	}
}

void solve(){
	int n;
	cin&gt;&gt;n;
	for (int i=1;i&lt;n;i++){
		int u,v,w;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		e[u].push_back({v,w});
		e[v].push_back({u,w});
	}
	dfs(1,-1);
	d[c]=0;//第二次dfs从c出发
	dfs(c,-1);
	cout&lt;&lt;d[c]&lt;&lt;endl;
}
</code></pre>
<hr />
<h3>树形DP：</h3>
<p>任取树上一点 $u$ ，$d_1,d_2$ 分别记录 $u$ 的子树中的最长路径和次长路径，需要计算的树的直径为 ${\rm{max}<em>{u=1}^n}(d</em>{1}+d_2)$</p>
<pre><code>int dfs(int x,int p){
	int d1=0;
	int d2=0;
	for (auto it:e[x]){
		if (it.v==p) continue;
		int td=dfs(it.v,x)+it.w;//计算子节点的最远路径
		if (td&gt;d1) d2=d1,d1=td;//更新最长路径和次长路径
		else if (td&gt;d2) d2=td;
		ans=max(ans,d1+d2);//记录答案
	}
	return d1;//返回当前节点的最长路径
}


void solve(){
	int n;
	cin&gt;&gt;n;
	for (int i=1;i&lt;n;i++){
		int u,v,w;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		e[u].push_back({v,w});
		e[v].push_back({u,w});
	}
	int x=dfs(1,-1);
	cout&lt;&lt;ans;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>二分图的染色法判定</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-03-16-%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-03-16-%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A/</id>
    <published>2025-03-16T00:00:00.000Z</published>
    <updated>2025-03-16T00:00:00.000Z</updated>
    <summary>判断一张图是否为二分图的算法</summary>
    <content type="html"><![CDATA[<p>二分图的染色法判定</p>
<hr />
<p>**二分图的定义：**如果一张无向图的 $n$ 个顶点可以分为 $A,B$ 两个不相交的集合，并且同一集合内的所有点之间没有边相连，记这张特征图为二分图</p>
<p>$\implies$ 每一条边都是连接两个集合的边，所以从一个集合出发需要经过偶数条边才能走回原来的集合</p>
<p><strong>推理：二分图不存在奇环（边数为奇数的环）</strong></p>
<p>**二分图的判定：**染色法，用两种不同的颜色标记整张图，当一个节点被颜色 $1$ 标记后，那么它相邻的节点会被标记颜色 $2$ ，如果标记过程中，存在颜色冲突，那么图中存在奇环</p>
<hr />
<pre><code>int n,m;
vector&lt;int&gt; e[N];

cin&gt;&gt;n&gt;&gt;m;
for (int i=1;i&lt;=m;i++) {
	int u,v;
	cin&gt;&gt;u&gt;&gt;v;
	e[u].push_back(v);
	e[v].push_back(u);
}
</code></pre>
<p>因为不考虑每条边的边权，所以之间利用 <code>vector&lt;int&gt; e[N]</code>  存图，<code>e[u]=v</code> 表示 $u$ 点到 $v$ 点存在一条边</p>
<p>然后 DFS 对每个点尝试染色</p>
<pre><code>int color[NN];//0表示没有被染色

bool dfs(int u,int c){//走到u点应该染c表示的颜色
	color[u]=c;
	for (auto v:e[u]){//遍历u点的邻点
		if (!color[v]){//如果没有被染色
			if (dfs(v,3-c)){//走到v点，dfs染3-c表示的颜色，c=1，3-c=2 c=2,3-c=1
				return 1;//如果dfs递归后为1，向上回溯1表示存在奇环
			}
		}
		if (color[v]==c)//如果冲突，递归结束，返回1，表示存在负环
			return 1;
	}
	return 0;//0表示不存在奇环
}
</code></pre>
<p><strong>对每个没有被染色的点进行一次 DFS ，直到整张图都被染色</strong></p>
<pre><code>bool f=0;//判断是否存在奇环
for (int i=1;i&lt;=n;i++){
	if (!color[i]){//如果没有被染色，那么从这个点开始dfs
		if (dfs(i,1)){
			f=1;
			break;
		}
	}
}
</code></pre>
<hr />
<p>例如洛谷P1330</p>
<p>题目要求的是找到最少的河蟹数量，使得每条边至少有一个端点被覆盖（河蟹占据），并且相邻的两个点不能同时有河蟹</p>
<p>这实际上等价于求图的一个顶点覆盖，且覆盖的顶点集合是一个独立集</p>
<p><strong>所以需要记录每次 DFS 过程中两种颜色点的数量，取最小的累加答案</strong></p>
<pre><code>
int n,m;
vector&lt;int&gt; e[10010];
int color[10010];
int ans,cnt1,cnt2;

bool dfs(int u,int c){
	color[u]=c;
	if (c==1) cnt1++;
	else cnt2++;
	for (auto v:e[u]){
		if (!color[v]){
			if (dfs(v,3-c)){
				return 1;
			}
		}
		if (color[v]==c)
			return 1;
	}
	return 0;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for (int i=1;i&lt;=m;i++) {
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	
	bool f=0;
	for (int i=1;i&lt;=n;i++){
		if (!color[i]){
			cnt1=0,cnt2=0;
			if (dfs(i,1)){
				f=1;
				break;
			}
			ans+=min(cnt1,cnt2);
		}
	}
	if (f) cout&lt;&lt;"Impossible";
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>Astar搜索算法</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-03-01-astar-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-03-01-astar-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</id>
    <published>2025-03-01T00:00:00.000Z</published>
    <updated>2025-03-01T00:00:00.000Z</updated>
    <summary>带有估价函数评估最优解的一种搜索方式</summary>
    <content type="html"><![CDATA[<p>Astar A* 算法路径搜索应用</p>
<p>在求解路径问题时，往往会搜索许多不必要的路径，计算机无法简单地实现人的宏观思维</p>
<p>所以，可以给当前需要搜索的路径增设一个估价函数，令计算机判断当前的最优解，这样可以节省许多不必要的时间开支</p>
<p>估价函数预处理出每个状态到目标状态的所需代价的估计值 $f(x)$，实际值为 $g(x)$，应当满足<strong>估计值不大于实际值</strong> $f(x)\le g(x)$ （越接近越准确），这样的带有估价函数的优先队列 BFS 叫做  Astar 算法</p>
<hr />
<p>在 BFS 过程中，维护一个堆，每次取出堆中 <strong>当前代价+未来估价</strong> 的最小状态进行扩展</p>
<p>例如求解第 $K$ 短路问题：给定 $n$ 个节点与 $m$ 条边的有向图，求从 $s$ 到 $t$ 的第 $K$ 短路</p>
<p><strong>未来估价函数的计算</strong></p>
<p>设 $f_i$ 表示第 $i$ 个节点到 $t$ 的距离，这里可以通过 Dijkstra 算法，以 $t$ 为起点 $s$ 为终点跑一遍，最后可以计算出精确的 $f_i=g_i$</p>
<p>注意需要额外存一张反向图，这里以 <code>rhe</code> 表示</p>
<pre><code>struct edge{
	long long v,w;
};
vector&lt;edge&gt; rhe[5010];

void dijkstra(void){
	priority_queue&lt;pair&lt;long long,long long&gt;&gt; q;
	memset(f,0x3f,sizeof f);
	f[t]=0;
	q.push({0,t});
	while (q.size()){
		auto t=q.top();
		q.pop();
		if (vis[t.second]) continue;
		vis[t.second]=1;
		for (auto iter:rhe[t.second]){
			if (f[iter.v]&gt;f[t.second]+iter.w){
				f[iter.v]=f[t.second]+iter.w;
				q.push({-f[iter.v],iter.v});
			}
		}
	}
}
</code></pre>
<p><strong>Astar的实现</strong></p>
<p>正向跑一边优先队列的 BFS，堆中维护三元组 ${dis_{s,i}+f_i,i,d}$，按照 $dis_{s,i}+f_i$ <strong>从小到大排序</strong></p>
<p>分别表示： $s$ 到 $i$ 的距离 + $i$ 到 $t$ 的未来估价函数，$i$ 点编号，$d$ 记录的总路径长度</p>
<p>在过程中，我们只允许每个点最多入队 $K$ 次，当 $t$ 节点第 $K$ 次出队时，对应三元组中的 $d$ 就为所求的第 $K$ 短路</p>
<pre><code>long long astar(void){
	priority_queue&lt;node&gt; q;
	q.push({f[S],S,0});
	while (q.size()){
		auto t=q.top();
		q.pop();
		cnt[t.v]++;
		if (cnt[T]==K)//终点出队k次
			return t.d;
		for (auto iter:he[t.v])
			if (cnt[iter.v]&lt;K)
				q.push({t.d+iter.w+f[iter.v],iter.v,t.d+iter.w});
	}
	return -1;
}
</code></pre>
<p>如果需要求严格的第 $K$ 短路，即当路径长度不同时才算为不同的第 $K$ 短路，需要增设一个变量记录上一次的答案</p>
<p>如果这一次得到路径长度与上一次相同，那么就需要令 $K+1$（当前的路径无效）</p>
<pre><code>struct node{
	long long s,v,d;
	bool operator&lt;(const node&amp;x)const{
		return s&gt;x.s;
	}//重载运算符，使优先队列按照s从小到大排列
};

long long mem=-1;

long long astar(void){
	priority_queue&lt;node&gt; q;
	q.push({f[s],s,0});
	while (q.size()){
		auto t=q.top();
		q.pop();
		
		if (t.v==K){
			if (mem==t.d) K++;
			else mem=t.d;
		}
		
		cnt[t.v]++;
		if (cnt[T]==K)
			return t.d
		for (auto iter:he[t.v])//he表示正向图
			if (cnt[iter.v]&lt;K)
				q.push({t.d+iter.w+f[iter.v],iter.v,t.d+iter.w});
	}
	return -1;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>同余式、乘法逆元、费马小定理</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-09-%E5%90%8C%E4%BD%99%E5%BC%8F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-09-%E5%90%8C%E4%BD%99%E5%BC%8F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</id>
    <published>2025-02-09T00:00:00.000Z</published>
    <updated>2025-02-09T00:00:00.000Z</updated>
    <summary>同余式的相关概念和模意义下的计算</summary>
    <content type="html"><![CDATA[<h3>同余式</h3>
<p>如果两个整数 $a,b$ 对 $m$ 取余的余数相同，则 $a,b$ 模 $m$ 同余，记作 <strong>$a\equiv b(mod\ m)$</strong></p>
<h3>乘法逆元</h3>
<p>若两个整数 $a,b$ 互质，且满足同余方程 $a\cdot x\equiv 1(mod\ b)$ ，则定义 $x$ 为 $a\ mod\ b$ 的乘法逆元，记作 $a^{-1}$</p>
<p>例如：$4x\equiv1(mod\ 5)$ 可以解得 $x=4,9,14\cdots(4+5\lambda)$ ，一般取小于 $b$ 的乘法逆元方程的<strong>特解</strong></p>
<h3>费马小定理</h3>
<p>若 $p$ 为质数，且 $a,p$ 互质，则满足同余式 $a^{p-1}\equiv1(mod\ p)$ ，例如：$2^{3-1}\equiv1(mod\ 3)$</p>
<ul>
<li>证明如下：</li>
</ul>
<p>​	首先存在一个质数为 $p$ ，根据<strong>欧拉函数</strong>的性质，与它互质的数即为 $[1,p-1]$ 其中的元素组成的序列，记为：
$$
A={1,2,3,\cdots,p-1}
$$
​	需要证明以下<strong>同余式</strong>成立：	
$$
\prod_{i=1}^{p-1} (a\times A_i)\equiv \prod_{i=1}^{p-1}A_i(mod\ p)\impliedby a^{p-1}\times \prod_{i=1}^{p-1} A_i\equiv \prod_{i=1}^{p-1}A_i(mod \ p)
$$
​	即说明每一个 $a\times A_i(mod \ p)$ 的余数都是<strong>互不相同</strong>的，推导过程有：</p>
<p>​	假设 $a\times A_i(mod\ p),a\times A_j(mod\ p)$ 的余数<strong>相同</strong>且为 $r$ ，则满足 $a\times A_i=xp+r,a\times A_j=yp+r$
$$
\implies a(A_i-A_j)=(x-y)p
$$
​	<strong>若 $r$ 存在</strong>，则 $a(A_i-A_j)$ 一定不为 $p$ 的倍数，<strong>当 $A_i\ne A_j $ 时</strong> $(x-y)p$  一定为 $p$ 的倍数，则等式不成立</p>
<p>​	反之就说明了每一个 $a\times A_i(mod \ p)$ 的余数都是互不相同</p>
<p><strong>又因为 $a\times A_i(mod\ p)&lt;p$ 恒成立，所以与 $A_i(mod \ p)$ 的余数集合必然相同</strong></p>
<p>则：
$$
a^{p-1}\times \prod_{i=1}^{p-1} A_i\equiv \prod_{i=1}^{p-1}A_i(mod \ p)
$$
两侧消去 $\prod_{i=1}^{p-1}A_i$ 后得到方程
$$
a^{p-1}\equiv 1 (mod\ p)
$$
例如：$p=5,A={ 1,2,3,4},a=2$，那么 $a\times A={2,4,6,8},a\times A\ %\ p={2,4,1,3}=A\ %\ p={1,2,3,4}$</p>
<h3>快速幂加速计算乘法逆元</h3>
<p>给定两个整数 $a,p$ ，$p$ 为质数，求 $a$ 模 $p$ 的乘法逆元</p>
<p>根据费马小定理有：$a^{p-1}\equiv1(mod \ p)\iff a\times a^{p-2}\equiv1(mod\ p)$，则 $a^{p-2}$ 即为 $a$ 模 $p$ 的乘法逆元</p>
<pre><code>cin&gt;&gt;a&gt;&gt;p;
cout&lt;&lt;quickpow(a,p-2,p);//调用快速幂计算a^(p-2)，过程中仍然需要对p取余

long long quickpow(long long a,long long b,long long p){
	long long res=1;
	while (b){
		if (b&amp;1) res=res*a%p;
		a=a*a%p;
		b&gt;&gt;=1;
	}
	return res;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>整除分块</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</id>
    <published>2025-02-05T00:00:00.000Z</published>
    <updated>2025-02-05T00:00:00.000Z</updated>
    <summary>暴力区间计算的一种优化方式</summary>
    <content type="html"><![CDATA[<h3>整除分块/数论分块</h3>
<p>快速计算一群向下取整的和式，打包同时计算拥有相同的 $\lfloor\frac{n}{i}\rfloor$ 的分式，时间复杂度可以优化到 $O(\sqrt n)$</p>
<p>例如需要计算
$$
\sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor
$$
依次写出拥有相同 $\lfloor\frac{n}{i}\rfloor$ 的分式
$$
\begin{array}{c|c|c|c|c|c|c|c|c|cc}</p>
<p>i&amp;1&amp;2&amp;3&amp;4&amp; 5&amp; 6\ 7&amp;8\ 9\ 10&amp;11\cdots21
\\hline
\lfloor\frac{n}{i}\rfloor&amp;21&amp;10&amp;7&amp;5&amp;4&amp;3&amp;2&amp;1
\end{array}
$$
分块存在两种性质：</p>
<ul>
<li>根据 $\lfloor\frac{n}{i}\rfloor$ 分块的数量 $\le2\lfloor \sqrt n\rfloor$</li>
</ul>
<p><strong>以 $\sqrt n$ 为分界线</strong>，$i\le \sqrt n$ 时，$\lfloor\frac{n}{i}\rfloor$ 有 $\lfloor\sqrt n\rfloor$ 种取值，$i&gt; \sqrt n$ 时，$\lfloor\frac{n}{i}\rfloor$ <strong>至多</strong>有 $\lfloor\sqrt n\rfloor$ 种取值</p>
<ul>
<li>$i$ 所在分块的右端点为 $rfub$</li>
</ul>
<p>$$
rfub=\lfloor \frac{n}{\lfloor \frac{n}{i}\rfloor}\rfloor
$$</p>
<p>设 $i$ 所在分块的 $\lfloor\frac{n}{i}\rfloor$ 为 $k$ ，则有以下推理
$$
k\le \frac{n}{i} \implies \frac{n}{k} \ge \frac{n}{\lfloor\frac{n}{i}\rfloor}\implies
\lfloor \frac{n}{k}\rfloor \ge \lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor
$$
又因为
$$
\lfloor \frac{n}{k}\rfloor \ge \lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor=\lfloor i\rfloor=i
$$
那么 $i$ 所在分块的区间为
$$
\lfloor\frac{n}{\lfloor k_{i-1} \rfloor}\rfloor\le i \le \lfloor\frac{n}{\lfloor k_{i} \rfloor}\rfloor=\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor
$$</p>
<hr />
<p><strong>综合以上两个性质，可以推广公式有</strong>
$$
\sum_{i=1}^n f(i)\lfloor\frac{n}{i}\rfloor
$$
首先通过<strong>前缀和预处理 $f(i)$</strong>
$$
s(i)=\sum_{j=1}^i f(j)
$$
那么答案就可以表示为
$$
\sum_{i=1}^n f(i)\lfloor\frac{n}{i}\rfloor=\sum_i [s(r)-s(l-1)]\cdot\lfloor\frac{n}{i}\rfloor
$$</p>
<hr />
<p><strong>以计算 $\sum_{i=1}^{n} k\ % \ i$ 为例</strong></p>
<p>和式可以变形为
$$
\sum_{i=1}^{n} k\ % \ i\implies \sum_{i=1}^{n} k-i*\lfloor\frac{k}{i}\rfloor=n<em>k-\sum_{i=1}^{n}i</em>\lfloor\frac{k}{i}\rfloor
$$
代码实现如下：</p>
<pre><code>long long n,k;
cin&gt;&gt;n&gt;&gt;k;
long long sum=n*k;
long long l,r;
for (l=1;l&lt;=n;l=r+1){//计算分块左边界
	if (k/l==0) break;//如果l大于k，那么之后的项都为0，提前中断
	r=min(k/(k/l),n);//如果计算的右边界超出n，那么就到n为止
	sum-=(k/l)*(r-l+1)*(l+r)/2;//等差数列计算
}
cout&lt;&lt;sum;
return 0;
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>筛法求欧拉函数</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</id>
    <published>2025-02-05T00:00:00.000Z</published>
    <updated>2025-02-05T00:00:00.000Z</updated>
    <summary>欧拉函数的定义以及计算的方式</summary>
    <content type="html"><![CDATA[<hr />
<h3>欧拉函数</h3>
<p>$1$ ~ $n$ 中与 $n$ 互质的数的个数叫做<strong>欧拉函数</strong>，记作 $\varphi (n)$</p>
<p>有性质如下：</p>
<ul>
<li>存在质数 $p$ ，则 $\varphi(p)=p-1$</li>
<li>存在质数 $p$ ，则 $\varphi(p^k)=(p-1)p^{k-1}$</li>
</ul>
<h1>于是可以推出欧拉函数的计算公式，根据惟一分解定理有
$$
n=\prod_{i=1}^sp_i^{\alpha_i}=p_1^{\alpha_1}p_2^{\alpha_2} \dots p_s^{\alpha_s}
$$
于是欧拉函数可以写为
$$
\varphi(n)=\prod_{i=1}^s\varphi(p_i^{s_i})</h1>
<p>\prod_{i=1}^s(p_i-1)p_i^{\alpha_i-1}
$$
$$
\Rightarrow\varphi(n)=\prod_{i=1}^sp_i^{\alpha_i}(1-\frac{1}{p_i})
=\prod_{i=1}^sp_i^{\alpha_i}\times \prod_{i=1}^s(1-\frac{1}{p_i})
$$
整理后得到
$$
\varphi(n)=n\times\prod_{i=1}^s\frac{p_i-1}{p_i}=n\times
\frac{p_1-1}{p_1}\times\frac{p_2-1}{p_2}\times\dots\times\frac{p_s-1}{p_s}
$$
<strong>观察上式可以发现欧拉函数只和 $n$ 与它的质因子有关</strong></p>
<h3>试除法求欧拉函数</h3>
<p>从小到大枚举 $\sqrt{n}$ 的质因子，计算 $\frac{p_i-1}{p_i}$ ，然后在 $n$ 中<strong>除掉这个质因子的所有贡献</strong></p>
<pre><code>long long get_phi(int n){
	long long res = n;
	for (long long i = 2; i * i &lt;= n; i++){
		if (n % i == 0){//判断i是否为n的质因子
			res = res * (i - 1) / i;//计算欧拉函数的部分
			while (n % i == 0) //把n中的这个质因子除干净
				n /= i;
		}
	}
	if (n &gt; 1) res = res * (n - 1) / n;/如果最后剩余的n大于1，那么n就是最后的一个最大质因子
	return res;
}
</code></pre>
<p><code>if (n &gt; 1) res = res * (n - 1) / n;</code> 加上这句判断的原因是：<strong>一个整数 $n$ 最多仅有一个超过 $\sqrt n$ 的质因子</strong></p>
<h3>筛法求欧拉函数</h3>
<p>通过线性筛法计算从 $1$ ~ $n$ 之间每个数的欧拉函数，以下是欧拉函数的另一个性质：</p>
<ul>
<li>若有 $gcd(m,n)=1$ （$m,n$互质），则 $\varphi(mn)=\varphi(m)\times\varphi(n)$</li>
</ul>
<pre><code>int p[N], vis[N], cnt;
int phi[N];

void get_phi(int n){
	for (int i = 2, i &lt;= n; i++){
		if (!vis[i]){
			p[cnt++] = i;
			phi[i] = i - 1;
		}
		for (int j = 0; i * p[j] &lt;= n; j++){
			int m = i * p[j];
			vis[m] = 1;
			if (i % p[j] == 0){
				phi[m] = p[j] * phi[i];
				break;
			}
			else
				phi[m] = (p[j] - 1) * phi[i];
		}
	}
}
</code></pre>
<p>如果枚举的 $i$ 为质数，那么 $\varphi(i)=i-1$</p>
<pre><code>//vis[i]==0
phi[i] = i - 1;
</code></pre>
<p>枚举的 $i$ 为合数（此时的 $i$ 已被之前的质因子筛到过），那么存在两种情况，<strong>可以向后递推合数</strong></p>
<ul>
<li>
<p>筛到的 $m$ 可以写作 $i*p_j$ ，如果 $i$ 能被 $p_j$ 整除，<strong>说明 $\varphi(m)=\varphi(i)$（$i$ 存在 $m$ 的所有质因子）</strong></p>
</li>
<li>
<p>如果 $i$ 不能被 $p_j$ 整除，说明 $i,p_j$ 互质，那么 $\varphi(m)=\varphi(i)*\varphi(p_j)$</p>
</li>
</ul>
<p><strong>如果只需要求单个数的欧拉函数，试除法比筛法更加优秀</strong></p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>Kruskal最小生成树算法.md</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-01-25-kruskal%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-01-25-kruskal%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</id>
    <published>2025-01-25T00:00:00.000Z</published>
    <updated>2025-01-25T00:00:00.000Z</updated>
    <summary>基于Kruskal重构树/并查集的最小生成树算法</summary>
    <content type="html"><![CDATA[<p>基于并查集实现的最小生成树算法，贪心选取最短的边，如果这条边连接的两个节点不在同一集合内，那就加入树</p>
<p>查询是否在同一集合已经合并集合的操作通过并查集实现</p>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

struct edge{
	int u,v,w;
};

vector&lt;edge&gt; e;
int n,m;
int fa[5010];
int cnt,sum;

int find(int x){
	if (x==fa[x])
		return x;
	return fa[x]=find(fa[x]);
}

bool kruskal(void){
	for (int i=0;i&lt;=n;i++) fa[i]=i;
	sort(e.begin(),e.end(),[](edge x,edge y){return x.w&lt;y.w;});
	for (auto [u,v,w]:e){
		int x=find(u),y=find(v);
		if (x!=y){
			cnt++;
			sum+=w;
			fa[x]=y;
		}
	}
	return cnt==n-1;
}

int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	
	int u,v,w;
	for (int i=1;i&lt;=m;i++){
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		e.push_back({u,v,w});
	}
	bool f=kruskal();
	if (f) cout&lt;&lt;sum;
	else cout&lt;&lt;"orz";
	return 0;
}
</code></pre>
<p>算法开始时，将每个节点的祖先节点初始化为自己</p>
<p>对每条边按照边权排序后从小到大遍历，如果这条边连接的两个节点的祖先不同，那么就将这两个节点所在的集合进行合并</p>
<p>查询祖先节点时，<strong>使用路径压缩优化，因为我们只需要求解最短路，和并查集内部的结构无关</strong></p>
<p>合并两个节点后，树内的节点数 $+1$ ，累加总边权</p>
<p>最后返回树内的节点数是否等于总节点数$-1$ ，如果相等，说明所有的点都可连通，最小生成树存在</p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>Prim最小生成树算法</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-01-19-prim%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2025-01-19-prim%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</id>
    <published>2025-01-19T00:00:00.000Z</published>
    <updated>2025-01-19T00:00:00.000Z</updated>
    <summary>一种基于贪心的最小生成树算法</summary>
    <content type="html"><![CDATA[<p>首先给出最小生成树的概念：<strong>把给定的无向图中转换成一棵树，且树的边权和最小</strong></p>
<p>Prim算法基于贪心的思想，每次在图中<strong>选取距离最小生成树最近的点</strong>加入树</p>
<p>首先给出朴素的模板算法：</p>
<pre><code>struct edge{
	int v,w;
};

int n,m;
vector&lt;edge&gt; e[5010];
int dis[5010];
bool vis[5010];
int cnt,sum;

void init(void){
	memset(dis,0x3f,sizeof dis);
}

bool prim(int s){
	init();
	dis[s]=0;
	while(1){
		int u=0;
		for (int i=1;i&lt;=n;i++){
			if (dis[i]&lt;dis[u]&amp;&amp;!vis[i])
				u=i;
		}
		if (u==0) break;
		vis[u]=1;
		cnt++;
		sum+=dis[u];
		for (auto it=e[u].begin();it!=e[u].end();it++){
			if (dis[it-&gt;v]&gt;it-&gt;w)
				dis[it-&gt;v]=it-&gt;w;
		}
	}
	return cnt==n;
}
</code></pre>
<p>其中的</p>
<pre><code>int u=0;
for (int i=1;i&lt;=n;i++){
	if (dis[i]&lt;dis[u]&amp;&amp;!vis[i])
		u=i;
}
if (u==0) break;
</code></pre>
<p>作用是找到一个距离最小生成树最近的点**（这个点还没有加入树）**</p>
<p>如果最后没有找到满足条件的点，就应该结束循环，退出 <code>while(1)</code></p>
<pre><code>vis[u]=1;//标记找到的这个点已经被加入树中
cnt++;//记录加入树的节点数加一
sum+=dis[u];//最小生成树的边权和
</code></pre>
<p>然后根据找到的这个点更新它<strong>连通的邻点到最小生成树的距离</strong></p>
<pre><code>for (auto it=e[u].begin();it!=e[u].end();it++){
	if (dis[it-&gt;v]&gt;it-&gt;w)
		dis[it-&gt;v]=it-&gt;w;
}
</code></pre>
<p>这里以一个连通图为例：</p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202501/3529184-20250119163856191-88995345.png" alt="" /></p>
<p>我们可以任意以一个点为 <code>s</code> 即起始点，<code>s=1</code> 时</p>
<p>第一轮：</p>
<p>树无节点，此时的<code>dis</code> 为 <code>dis[]={inf,0,inf,inf,inf}</code>，从小到大找到 <code>1</code> 为最小点，<code>1</code> 加入最小生成树</p>
<p>然后更新 <code>1</code> 的邻点，<code>dis={inf,0,2,2,6}</code></p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202501/3529184-20250119163909050-1732862037.png" alt="" /></p>
<p>第二轮：</p>
<p>树节点有 <code>1</code>，此时的<code>dis</code> 为 <code>dis[]={inf,0,2,2,6}</code>，从小到大找到 <code>2</code> 为最小点，<code>2</code> 加入最小生成树</p>
<p>然后更新 <code>2</code> 的邻点，<code>dis={inf,0,2,2,6}</code></p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202501/3529184-20250119163918628-861116574.png" alt="" /></p>
<p>第三轮：</p>
<p>树节点有 <code>1,2</code>，此时的<code>dis</code> 为 <code>dis[]={inf,0,2,2,6}</code>，从小到大找到 <code>3</code> 为最小点，<code>3</code> 加入最小生成树</p>
<p>然后更新 <code>3</code> 的邻点，<code>dis={inf,0,2,2,3}</code></p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202501/3529184-20250119163929205-611554088.png" alt="" /></p>
<p>第三轮：</p>
<p>树节点有 <code>1,2,3</code>，此时的<code>dis</code> 为 <code>dis[]={inf,0,2,2,3}</code>，从小到大找到 <code>4</code> 为最小点，<code>4</code> 加入最小生成树</p>
<p>然后更新 <code>4</code> 的邻点，<code>dis={inf,0,2,2,3}</code></p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202501/3529184-20250119163938040-1673620431.png" alt="" /></p>
<p>第四轮：</p>
<p>树节点有 <code>1,2,3,4</code>，此时的<code>dis</code> 为 <code>dis[]={inf,0,2,2,3}</code>，找不到满足条件的点，退出循环</p>
<pre><code>return cnt==n;
</code></pre>
<p><strong>返回所有的点是否都加入了树，如果没有全部进树，说明存在不连通点</strong></p>
<h3>同样的，对于找最近点的操作可以使用 <code>priority_queue</code> 优先队列优化</h3>
<pre><code>priority_queue&lt;pair&lt;int,int&gt;&gt; q;

bool prim(int s){
	init();
	dis[s]=0;
	q.push({0,s});
	while (q.size()){
		auto t=q.top();
		q.pop();
		if (vis[t.second]) continue;
		vis[t.second]=1;
		sum-=t.first;
		cnt++;
		for (auto it=e[t.second].begin();it!=e[t.second].end();it++){
			if (dis[it-&gt;v]&gt;it-&gt;w){
				dis[it-&gt;v]=it-&gt;w;
				q.push({-dis[it-&gt;v],it-&gt;v});
			}
		}
	}
	return cnt==n;
}
</code></pre>
<p>使用优先队列优化后仍然不要忘记判断点和树的关系</p>
<pre><code>if (vis[t.second]) continue;//如果不是没有进树的点，那就重新找
</code></pre>
<hr />
<p>区别于最短路的问题，最小生成树更新边的关系原理不一样</p>
<pre><code>for (auto it=e[u].begin();it!=e[u].end();it++){//此时的u已经进了树
	if (dis[it-&gt;v]&gt;it-&gt;w)//到树的距离为dis[v]和w
		dis[it-&gt;v]=it-&gt;w;//取两者最小，即更新最短距离
}
</code></pre>
<p>在最小生成树中，把边权重新更新为 <strong>到树的最短距离</strong>，而非最短路中的到起始点的最短距离</p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>质数筛</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-01-02-%E8%B4%A8%E6%95%B0%E7%AD%9B/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-01-02-%E8%B4%A8%E6%95%B0%E7%AD%9B/</id>
    <published>2025-01-02T00:00:00.000Z</published>
    <updated>2025-01-02T00:00:00.000Z</updated>
    <summary>选取质数的多种方式</summary>
    <content type="html"><![CDATA[<hr />
<h3>试除法判定质数</h3>
<p>暴力做法：枚举 $2$ ~ $n-1$ 的所有数，判断能否将 $n$ 整除，如果存在一个数能把 $n$ 整数，说明 $n$ 不是质数</p>
<p>实际上只需要枚举到 $\sqrt{n}$ 即可，如果 $a$ 是 $n$ 的约数，那么 $\frac{n}{a}$ 也是 $n$ 的约数，我们只需要检验 $min(a,\frac{n}{a})$ 即可</p>
<pre><code>bool is_prime(int x){
	if (x == 1) return 0;//1不是质数
	for (long long i = 2; i &lt;= sqrt(x); i++)//从小到大枚举
		if (x % i == 0) return 0;//如果能整除，立即返回非质数
	return 1;//返回是质数
}
</code></pre>
<p>具体的计算中，<code>i &lt;= sqrt(x)</code> 的操作可以优化为 <code>i * i &lt;= x</code> 或 <code>i &lt;= x / i</code> ，得到常数级的优化</p>
<p><strong>不难看出对于判断 $n$ 而言，试除法判断质数的时间复杂度为 $O(\sqrt{n})$</strong></p>
<h3>埃拉托斯特尼筛法</h3>
<p>这是一种在给定区间内有效筛选素数的方式，原理是：</p>
<ul>
<li>从 $2$ 开始枚举每一个数，直到到达给定的界限</li>
<li>对每一个枚举的数都判断一次状态</li>
<li>枚举<strong>当前质数的倍数</strong>，他们必然是合数，更改状态</li>
</ul>
<p>最后每个数都存在一个状态，<strong>要么被标记为合数，要么被标记为质数</strong>，这就完成了筛选素数的过程</p>
<pre><code>bool st[N];//状态数组，合数被标记为 1，初始化时都为 0
int prime_mem[N];//记录素数
int cnt;//素数个数

void Eratosthens(int n){
	for (long long i = 2; i &lt;= n; i++){//从小到大枚举
		if (!st[i]){//如果这个数是素数
			prime_mem[++cnt] = i;//素数个数加 1，并记录
			for (long long j = i * i; j &lt;= n; j += i)//从小到大枚举素数的倍数
				st[j] = 1;//标记素数
		}
	}
}
</code></pre>
<p>其中 <code>for (long long j = i * i; j &lt;= n; j += i)</code> 从 <code>i * i</code> 开始标记合数，<strong>这是因为小于 <code>i * i</code> 的合数在之前已经被标记过了</strong></p>
<p>证明如下：</p>
<ul>
<li>设 $k &lt; i\quad k\in N^+$，则 $ki $ 为 $i$ 的倍数，满足 $ki&lt;i^2$</li>
</ul>
<p>$$
ki&lt;i^2 \iff k&lt;i
$$</p>
<ul>
<li>存在质数$p$， $p&lt;i$，$p$ 标记了它的倍数 $kp$ ，就有</li>
</ul>
<p>$$
p\times k=p \iff k=1
$$</p>
<ul>
<li>由于 $k&lt;i$ ，所以下述不等式成立</li>
</ul>
<p>$$
p\times k&lt;p\times i&lt;i^2 \iff p&lt;i,k&lt;i
$$</p>
<p><strong>所以任意的小于 $i^2$ 的合数，都已经被小于 $i$ 的一个素数 $p$ 标记过</strong></p>
<p>显然，<strong>根据算数基本定理，要找到 $n$ 以内的所有质数，只需要对不超过 $\sqrt{n}$ 的素数进行筛除即可</strong></p>
<p><code>for (long long i = 2; i &lt;= n; i++)</code> $\rightarrow$ <code>for (long long i = 2; i * i &lt;= n; i++)</code></p>
<p>这种筛法的时间复杂度在 $O(n\log\log n)$ ，近乎于 $O(n)$</p>
<h3>线性筛法/欧拉筛法</h3>
<p>对于上面的埃拉托斯特尼筛法，过程中会对一个合数重复标记多次，通过线性筛法，可以做到让一个合数只被标记一次</p>
<p><strong>那么时间复杂度就能降到 $O(n)$</strong></p>
<p>原理如下：</p>
<ul>
<li><strong>合数总是可以分解为多个质数的积</strong>，（整数惟一分解定理）</li>
<li>使筛掉的方法唯一，每次通过<strong>合数的最小质因子</strong>筛掉</li>
</ul>
<pre><code>bool st[N];//状态数组，合数被标记为 1，初始化时都为 0
int prime_mem[N];//记录素数
int cnt;//素数个数

void Euler(int n){
	for (long long i = 2; i &lt;= n; i++){
		if (!st[i]) prime_mem[++cnt] = i;
		for (long long j = 1; i * prime_mem[j] &lt;= n; j++){
			st[i * prime_mem[j]] = 1;
			if (i % prime_mem[j] == 0) break;//保证只被最小质因子筛除
		}
	}
}
</code></pre>
<p>$i$ 为质数，最多枚举到自身中断，即 $i^2\ %\   i=0$ 。$i$ 为合数，<strong>最多枚举到最小质因子 $p$ 结束</strong>，即 $i*p\ %\ i=0$</p>
<p><strong>其中的 <code>st[i * prime_mem[j]] = 1;</code> 做到了具体的筛除过程</strong></p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>Bellman-Ford SPFA单源最短路.md</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-31-bellman-ford-spfa%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-31-bellman-ford-spfa%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/</id>
    <published>2024-12-31T00:00:00.000Z</published>
    <updated>2024-12-31T00:00:00.000Z</updated>
    <summary>可以处理负边权和判断负环的一种最短路算法</summary>
    <content type="html"><![CDATA[<h2><strong>不采用 SPFA 实现的Bellman-Ford算法</strong></h2>
<p><em>" 题目中的图没有特殊性质时，若 SPFA 是标算的一部分，题目不应当给出 Bellman–Ford 算法无法通过的数据范围 "</em></p>
<hr />
<p>Bellman-Ford的原理如下</p>
<p>先枚举节点，在枚举边，每进行一轮循环，对图上所有的边都尝试进行一次<strong>松弛操作</strong>，当一次循环中没有成功的松弛操作时，退出循环</p>
<ul>
<li><strong>判断负环的存在 （有$n$ 个节点）</strong></li>
</ul>
<p>对于最短路存在的情况下，对这个节点进行一次松弛操作会使最短路的边数至少增加 $1$ ，又因为图上的最短路的边数最多为 $n-1$</p>
<p><strong>所以松弛操作最多只会执行 $n-1$ 轮</strong></p>
<p>如果第 $n$ 轮时我们还能对一条边进行松弛操作，说明能够到达一个负环，<strong>在这个环上没有最短路定义</strong>，可以一直松弛下去</p>
<pre><code>struct edge {
    int v, w; // 目标节点 v 和边权重 w
};

void init(void){
    memset(dis,0x3f,sizeof dis);
}

bool bellman_ford(int s){
    init();
    dis[s]=0;
    bool flag;
    for (int i=1;i&lt;=n;i++){//进行 n 轮
        flag=0;
        for (int u=1;u&lt;=n;u++){//遍历所有节点
            if (dis[u]==0x3f3f3f3f) continue;
            for (auto it=e[u].begin();it!=e[u].end();it++){//遍历与u连通的边
                if (dis[it-&gt;v]&gt;dis[u]+it-&gt;w){//松弛操作
                    dis[it-&gt;v]=dis[u]+it-&gt;w;
                    flag=1;//标记这一轮可以松弛
                }
            }
        }
        if (!flag) break;//如果无法松弛，提前退出循环
    }
    return flag;//返回最后的标志，判断是否存在负环
}
</code></pre>
<p>其中，定义 <code>flag</code> 来判断是否能进行松弛操作，最后在第 $n$ 轮时 <code>flag</code> 仍然为 $1$ ，说明存在负环</p>
<p><code>if (dis[u]==0x3f3f3f3f) continue;</code> 表示如果当前节点不能到达，那就跳过这个节点</p>
<ul>
<li>时间复杂度判断</li>
</ul>
<p>对于每轮循环，内层的两个 <code>for</code> 都在干一件事情，那就是<strong>更新所有的边</strong>，所以一轮的复杂度就为 $O(m)$，总的时间复杂度就为 $O(nm)$</p>
<h2>优化方案——SPFA(Shortest Path Faster Algorithm)</h2>
<p>朴素的算法中，我们会执行的不必要操作就是每轮都遍历所有的边</p>
<p>事实上，只有<strong>上一轮更新过的点才能引起这一轮的松弛操作</strong>，所以可以把上一轮更新的点记录下来，这一轮直接对这些点进行松弛操作</p>
<p>采用的是队列 <code>queue</code> 这一数据结构来维护更新的点</p>
<pre><code>queue&lt;int&gt; q;
</code></pre>
<p>另外还需要<code>cnt</code> 和 <code>vis</code> 数组来记录<strong>当前节点最短路的边数</strong>以及<strong>是否在队中</strong></p>
<pre><code>bool vis[2010];
int cnt[2010];
</code></pre>
<p>SPFA：</p>
<pre><code>bool spfa(int s) {
	init();
	dis[s] = 0;
	q.push(s);
	vis[s] = 1;
	while (q.size())
	{
		int t = q.front(); q.pop();
		vis[t] = 0;//取出队列
		for (auto it = e[t].begin(); it != e[t].end(); it++) {
			if (dis[it-&gt;v] &gt; dis[t] + it-&gt;w) {
				dis[it-&gt;v] = dis[t] + it-&gt;w;
				cnt[it-&gt;v] = cnt[t] + 1;
				if (cnt[it-&gt;v] &gt;= n) return 1;//判断负环
				if (!vis[it-&gt;v]) {//压入队列
					q.push(it-&gt;v);
					vis[it-&gt;v] = 1;
				}
			}
		}
	}
	return 0;
}
</code></pre>
<p>首先将起点 <code>s</code> 压入队列，<code>vis[s] = 1</code> 表明在队中</p>
<ul>
<li>循环直到队列为空，即不能松弛结束</li>
<li>根据最短路的边数来判断负环</li>
</ul>
<p><strong>如果一个点的最短路边数大于等于了节点数 <code>n</code> ，说明一定存在一个负环导致某些边的经过次数大于 $1$</strong> ，及时退出</p>
<p>如果当前的节点能够进行松弛操作，并且<strong>当前还不在队列中</strong>，就把他<strong>压入队列</strong></p>
<hr />
<h4>大多数情况下 SPFA 跑得很快，但其最坏情况下的时间复杂度和朴素算法一样为 $O(nm)$</h4>
<h3>谨防卡 SPFA ，非负权图就用 Dijkstra</h3>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>分层图问题</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-30-%E5%88%86%E5%B1%82%E5%9B%BE%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-30-%E5%88%86%E5%B1%82%E5%9B%BE%E9%97%AE%E9%A2%98/</id>
    <published>2024-12-30T00:00:00.000Z</published>
    <updated>2024-12-30T00:00:00.000Z</updated>
    <summary>节点按照某些性质划分为不同层次的最短路处理方式</summary>
    <content type="html"><![CDATA[<hr />
<p>这里以一道题目为例</p>
<p><strong>题目描述</strong></p>
<p>Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。</p>
<p>Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？</p>
<p><strong>输入格式</strong></p>
<p>第一行三个整数 $n,m,k$，分别表示城市数，航线数和免费乘坐次数。</p>
<p>接下来一行两个整数 $s,t$，分别表示他们出行的起点城市编号和终点城市编号。</p>
<p>接下来 $m$ 行，每行三个整数 $a,b,c$，表示存在一种航线，能从城市 $a$ 到达城市 $b$，或从城市 $b$ 到达城市 $a$，价格为 $c$。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个整数，为最少花费。</p>
<p><strong>样例输入</strong></p>
<pre><code>5 6 1
0 4
0 1 5
1 2 5
2 3 5
3 4 5
2 3 3
0 2 100
</code></pre>
<p><strong>样例输出</strong></p>
<pre><code>8
</code></pre>
<p><strong>数据规模与约定</strong></p>
<p>对于 $30%$ 的数据，$2 \le n \le 50$，$1 \le m \le 300$，$k=0$。</p>
<p>对于 $50%$ 的数据，$2 \le n \le 600$，$1 \le m \le 6\times10^3$，$0 \le k \le 1$。</p>
<p>对于 $100%$ 的数据，$2 \le n \le 10^4$，$1 \le m \le 5\times 10^4$，$0 \le k \le 10$，$0\le s,t,a,b &lt; n$，$a\ne b$，$0\le c\le 10^3$。</p>
<p>另外存在一组 hack 数据。</p>
<hr />
<p>区别与一般的单图问题，这道题中我们需要考虑<strong>可以免费坐飞机的航线</strong></p>
<p>相当于每个节点都存在一个<strong>状态</strong>，即到这个节点还能免费坐飞机的次数</p>
<h3>拥有相同状态的节点共同组成一张图</h3>
<p>所以需要对寻路的方式进行部分修改，这里采用优先队列的Dijkstra最短路算法</p>
<pre><code>struct node
{
	int dw, dnode, cnt;
	bool operator&lt;(const node&amp; a)const {
		return dw &gt; a.dw;
	}
};
</code></pre>
<p>构造优先队列 <code>priority_queue</code> 使用的结构体，并<strong>重载小于号</strong></p>
<p>其中存储了这个节点的编号<code>dnode</code> ，节点到起始点的距离 <code>dw</code> ，以及当前节点使用的免费次数 <code>cnt</code></p>
<pre><code>int dis[20010][12];
bool vis[20010][12];
</code></pre>
<p>同样的，记录最短距离的 <code>dis</code> 和记录访问节点的 <code>vis</code> 数组都需要<strong>根据状态的不同来进行分层操作</strong></p>
<pre><code>void dijkstra(int st) {
	init();
	q.push({ 0, st, 0 });
	dis[st][0] = 0;
	while (q.size())
	{
		const node ttop = q.top();
		q.pop();
		if (vis[ttop.dnode][ttop.cnt]) continue;
		vis[ttop.dnode][ttop.cnt] = 1;
		
		for (auto it = e[ttop.dnode].begin(); it != e[ttop.dnode].end(); it++) {
			if (ttop.cnt &lt; k&amp;&amp; dis[it-&gt;v][ttop.cnt + 1] &gt; dis[ttop.dnode][ttop.cnt]) {
				dis[it-&gt;v][ttop.cnt + 1] = dis[ttop.dnode][ttop.cnt];
				q.push({ dis[it-&gt;v][ttop.cnt + 1],it-&gt;v,ttop.cnt + 1 });
			}
			if (dis[it-&gt;v][ttop.cnt] &gt; dis[ttop.dnode][ttop.cnt] + it-&gt;w) {
				dis[it-&gt;v][ttop.cnt] = dis[ttop.dnode][ttop.cnt] + it-&gt;w;
				q.push({ dis[it-&gt;v][ttop.cnt],it-&gt;v,ttop.cnt });
			}
		}
		
	}
}
</code></pre>
<p>除了松弛操作外，多层图和单图的源码几乎相同，都采用了优先队列贪心来找当前最优的节点</p>
<p><strong>在松弛操作内，我们需要考虑当前的节点能否使用免费的次数，免费后是不是最优</strong></p>
<ul>
<li>当前的节点可以免费</li>
</ul>
<pre><code>if (ttop.cnt &lt; k&amp;&amp; dis[it-&gt;v][ttop.cnt + 1] &gt; dis[ttop.dnode][ttop.cnt]) {//判断是不是最优
	dis[it-&gt;v][ttop.cnt + 1] = dis[ttop.dnode][ttop.cnt];//如果能更新最短路径，那就更新
	q.push({ dis[it-&gt;v][ttop.cnt + 1],it-&gt;v,ttop.cnt + 1 });//将更新后的节点放入队列，注意状态也要更新
}
</code></pre>
<ul>
<li>当前的节点不能免费或不采取免费</li>
</ul>
<pre><code>if (dis[it-&gt;v][ttop.cnt] &gt; dis[ttop.dnode][ttop.cnt] + it-&gt;w) {//判断能否更新
	dis[it-&gt;v][ttop.cnt] = dis[ttop.dnode][ttop.cnt] + it-&gt;w;
	q.push({ dis[it-&gt;v][ttop.cnt],it-&gt;v,ttop.cnt });//放入更新后的节点
}
</code></pre>
<hr />
<p>Dijkstra寻路结束后，我们遍历一遍终点节点的所有状态，找到一个最小的<code>dis[ed][i]</code>，即最优解</p>
<pre><code>int ans = 1e9;
for (int i = 0; i &lt;= k; i++) ans = min(ans, dis[ed][i]);
</code></pre>
<hr />
<p><img src="https://img2024.cnblogs.com/blog/3529184/202412/3529184-20241230171029195-231731647.png" alt="" /></p>
<p>图上的每一个节点都有向<strong>下层的可联通节点</strong>前进的无权边（免费）</p>
<p>上图以 $0$ 号节点为例，它可以通过免费次数<strong>构建出来的边</strong>向下层图移动，直到免费次数用尽</p>
<h3>总而言之，解决分层图的关键就在建图，需要正确地通过不同的状态构造出图</h3>
<p>完整代码：</p>
<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#define streampreset() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
using namespace std;

struct edge
{
	int v, w;
};

struct node
{
	int dw, dnode, cnt;
	bool operator&lt;(const node&amp; a)const {
		return dw &gt; a.dw;
	}
};

int n, m, k;
int st, ed;
vector&lt;edge&gt; e[50010];
priority_queue&lt;node&gt; q;
int dis[20010][12];
bool vis[20010][12];

void insert(int u, int v, int w) {
	e[u].push_back({ v,w });
}

void init(void) {
	memset(dis, 0x3f, sizeof dis);
}

void dijkstra(int st) {
	init();
	q.push({ 0, st, 0 });
	dis[st][0] = 0;
	while (q.size())
	{
		const node ttop = q.top();
		q.pop();
		if (vis[ttop.dnode][ttop.cnt]) continue;
		vis[ttop.dnode][ttop.cnt] = 1;
		for (auto it = e[ttop.dnode].begin(); it != e[ttop.dnode].end(); it++) {
			if (ttop.cnt &lt; k&amp;&amp; dis[it-&gt;v][ttop.cnt + 1] &gt; dis[ttop.dnode][ttop.cnt]) {
				dis[it-&gt;v][ttop.cnt + 1] = dis[ttop.dnode][ttop.cnt];
				q.push({ dis[it-&gt;v][ttop.cnt + 1],it-&gt;v,ttop.cnt + 1 });
			}
			if (dis[it-&gt;v][ttop.cnt] &gt; dis[ttop.dnode][ttop.cnt] + it-&gt;w) {
				dis[it-&gt;v][ttop.cnt] = dis[ttop.dnode][ttop.cnt] + it-&gt;w;
				q.push({ dis[it-&gt;v][ttop.cnt],it-&gt;v,ttop.cnt });
			}
		}
	}
}

int main()
{
	streampreset();
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; st &gt;&gt; ed;
	int u, v, w;
	for (int i = 0; i &lt; m; i++) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		insert(u, v, w);
		insert(v, u, w);
	}
	dijkstra(st);
	int ans = 1e9;
	for (int i = 0; i &lt;= k; i++) ans = min(ans, dis[ed][i]);
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>Dijkstra单源最短路堆优化算法</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-23-dijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%A0%86%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-23-dijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%A0%86%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</id>
    <published>2024-12-23T00:00:00.000Z</published>
    <updated>2024-12-23T00:00:00.000Z</updated>
    <summary>基于堆优化的Dijkstra最短路算法</summary>
    <content type="html"><![CDATA[<p>使用基于堆的优先队列，我们可以在进行松弛操作前对找边进行优化操作</p>
<p>时间复杂度为 $O(m\log m)$ ，其中 $m$ 为边的数量，优先队列找边的时间复杂度为$O(\log m)$</p>
<h3>优先队列</h3>
<p>默认为一个大根堆，即堆顶的元素的<strong>优先级最高</strong>，体现在某个<strong>变量的值</strong>上</p>
<p>每次从队列中取出堆顶元素，我们依据堆的特性，可以选出当前最优的节点，再对这个节点进行访问，对其可联通点进行一轮<strong>松弛操作</strong>，最后将这些点<strong>依次压入队列</strong>中，优先队列会帮助我们将这些点进行<strong>优先级排序</strong></p>
<p>对于Dijkstra而言，我们将节点放入优先队列中，我们的边权<code>w</code>作为的是<strong>优先级评判变量</strong>，但是，我们最优考虑的点为<strong>边权最小的点</strong>，所以这就有两种办法来解决这个问题</p>
<ul>
<li><strong>将边权取负后放入队列</strong></li>
<li><strong>使用重载运算符，实现小根堆的优先队列</strong></li>
</ul>
<p>介绍第一种操作：</p>
<p>边权作为优先队列的优先级依据，它的值越大优先级越高，我们需要值越小（当前最优）的边优先级最高，所以可以先对边权取负再放入队列中</p>
<pre><code>priority_queue&lt;pair&lt;int, int&gt;&gt; q;//二元组队列，存储边权和联通点
void dijkstra(int s) {
	presetdis();//预处理距离
	q.push({ 0,s });//起始点到自己的距离为0，压入队列
	dis[s] = 0;
	while (q.size())//当队列不空时
	{
		auto t = q.top();//取出堆顶元素
		q.pop();//弹出堆顶元素
		if (vis[t.second]) continue;//如果堆顶元素这个节点已被访问过，重新取元素
		vis[t.second] = 1;//标记这个节点已被访问
		for (auto it = e[t.second].begin(); it != e[t.second].end(); it++) {//迭代访问
			dis[it-&gt;v] = min(dis[t.second] + it-&gt;w, dis[it-&gt;v]);//松弛操作
			q.push({-(dis[it-&gt;v]),it-&gt;v});//压入更新后的节点
		}
	}
}

</code></pre>
<p><strong>其中，<code>first</code>存储边权，<code>second</code>记录联通点，优先队列默认以<code>pair</code>的<code>first</code>作为优先级标准</strong></p>
<p><code>q.push({-(dis[it-&gt;v]),it-&gt;v})</code>对权值取负，即依靠大根堆直接排序</p>
<hr />
<p><strong>重载运算符的操作</strong></p>
<p>先来看一下<code>priority_queue</code>的原型声明</p>
<p>其中的 <code>Type</code>为数据类型，<code>Container</code>为容器（<code>vector</code>,<code>deque</code>...），<code>Functional</code>为比较方式</p>
<pre><code>priority_queue&lt;Type, Container, Functional&gt;
</code></pre>
<p>对于一般的<strong>独立变量</strong>而言，构造小根堆只需要在默认的大根堆写法上稍加修改</p>
<pre><code>priority&lt;int&gt; q;//大根堆
priority&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;//小根堆
</code></pre>
<p>处理结构体变量时，需要更复杂的操作，使优先队列依照结构体内的<strong>某个成员进行优先级排序</strong></p>
<p>这里使用的是定义 <code>cmp</code> 函数，<strong>重载运算符</strong>来进行小根堆的实现</p>
<pre><code>struct node{
    int x;
    int y;
};
struct cmp{
    bool operator()(node a,node b){
        return a.x &gt; b.x;
    }
};
priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; q;
</code></pre>
<p><code>struct cmp</code> 定义了一个自定义的比较器，<code>operator()</code> 是一个重载运算符，允许 <code>cmp</code> 作为函数对象使用</p>
<p>接收两个 <code>node</code> 对象 <code>a</code> 和 <code>b</code>，如果 <code>a.x</code> 大于 <code>b.x </code>就返回 <code>true</code> ，优先队列将根据 <code>x</code> 的值进行排序，<strong>较小的 <code>x</code> 值优先</strong></p>
<p><strong>注意，这里的 <code>cmp</code> 函数逻辑和 <code>sort</code> 中的 <code>cmp</code> 的逻辑相反</strong></p>
<pre><code>bool compare(node a, node b) {
    return a.x &gt; b.x; // 降序排序，大的值在前
}
//当 a.x 大于 b.x 时，返回 true,表示在优先队列中，a 不是优先于 b 的

bool operator()(node a, node b) {
    return a.x &gt; b.x;// 小根堆，大的值优先级更低
}
当 a.x 小于 b.x 时，返回 true，表示 a 在 b 之前
</code></pre>
<hr />
<p>也可以将重载运算符的操作放在结构体内</p>
<pre><code>struct node{
    int x;
    int y;
    bool operator&lt;(const node &amp;a) const
    {
        return x&lt;a.x;
    }
};
priority_queue&lt;node&gt; q;
</code></pre>
<p><code>node</code> 的 <code>x</code> 值被用来进行比较，这里是 <code>x &lt; a.x</code>，表示当 <code>x</code> 值较大时会被认为是**“优先级较大”**的</p>
<p>优先队列在处理 <code>node</code> 时，将会以 <code>x</code> 值从大到小的顺序排列</p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>欧几里得算法、惟一分解定理</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2024-12-19-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%83%9F%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2024-12-19-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%83%9F%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/</id>
    <published>2024-12-19T00:00:00.000Z</published>
    <updated>2024-12-19T00:00:00.000Z</updated>
    <summary>一种求最大公约数算法和质因数分解</summary>
    <content type="html"><![CDATA[<hr />
<h3>欧几里得算法（辗转相除法）求最大公约数GCD</h3>
<p>有两个整数 $a,b(a&gt;b)$ ，记它们的最大公约数为 $gcd(a,b)$，对于任意的 $a,b\ne 0$ 满足等式 ：
$$
gcd(a,b)=gcd(b,a% b)
$$</p>
<ul>
<li>
<p>充分性证明：</p>
<p>设 $d$ 为 $a,b$ 的最大公约数，那么有 $d\mid a$ 和 $d\mid b$ 成立，组合出 $d\mid (a-kb),\ (k\in N)$ 也成立，其中 $a-kb=a%b$</p>
</li>
<li>
<p>必要性证明：</p>
<p>设 $d$ 为 $a,a% b$ 的最大公约数，那么有 $d\mid a$ 和 $d\mid (a-kb),\ (k\in N)$ 成立，同样可以组合出 $d\mid b$ 成立</p>
</li>
</ul>
<p>程序设计中可以递归求解，递归出口为 $a,b=0$ ，其中不为 $0$ 的项即为最大公约数（$a&gt;b$）</p>
<pre><code>int gcd(int a, int b){
	if (b == 0) return a;
	return gcd(b, a % b);
}
</code></pre>
<ul>
<li>
<p>复杂度分析：</p>
<p>对 $a$ 取 $b$ 的模时，至少可以将 $a$ 缩小到 $a/2$ ，即 $a% b \le a/2$ ，证明如下</p>
<ul>
<li>$b&lt; a/2$ 时，$a% b&lt;b&lt; a/2$</li>
<li>$b&gt;a/2$ 时，$a%b=a-b\le a/2$</li>
<li>$b=a/2$ 时，$a% b=0&lt;a/2$ （特殊状况，$b$ 为 $a$ 因子）</li>
</ul>
</li>
</ul>
<h3>最小公倍数LCM</h3>
<p>有两个整数 $a,b(a,b\ne 0)$ ，记它们的最小公倍数为 $lcm(a,b)$，对于任意的 $a,b\ne 0$ 满足等式 ：
$$
lcm(a,b)=\frac{a\times b}{gcd(a,b)}
$$</p>
<p>计算LCM需要先计算出GCD，采用<strong>先除后乘防止溢出</strong></p>
<pre><code>int lcm(int a, int b){
		return a / gcd(a, b) * b;
}
</code></pre>
<h3>算数基本定理（整数惟一分解定理）</h3>
<p>对于任意的一个正整数 $n$ ，有且仅有一种由<strong>质数的乘积</strong>所表达的方式
$$
n=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdot\cdot\cdot p_s^{\alpha_s}
\quad \quad
p_1&lt;p_2&lt;\cdot \cdot\cdot&lt;p_s
$$</p>
<ul>
<li>
<p>$n$  至多含有一个大于 $\sqrt{n}$ 的质因子</p>
<p>根据上述的表达方式可以反推，若有两个大于 $\sqrt{n}$ 的质因子，它们的乘积一定大于了 $n$</p>
</li>
<li>
<p><strong>证明LCM表达式</strong></p>
<h1>设 ：
$$
a=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdot\cdot\cdot p_s^{\alpha_s}
\
b=p_1^{\beta_1}\cdot p_2^{\beta_2}\cdot\cdot\cdot p_s^{\beta_s}
$$
那么 $gcd(a,b)$ 与 $lcm(a,b)$ 可表示为
$$
gcd(a,b)=p_1^{min(\alpha_1,\beta_1)}\cdot p_2^{min(\alpha_2,\beta_2)}\cdot\cdot\cdot p_s^{\min(\alpha_s,\beta_s)}
$$
$$
lcm(a,b)=p_1^{max(\alpha_1,\beta_1)}\cdot p_2^{max(\alpha_2,\beta_2)}\cdot\cdot\cdot p_s^{\max(\alpha_s,\beta_s)}
$$
因为满足以下的约束条件
$$
min(\alpha_i,\beta_i)+max(\alpha_i,\beta_i)=\alpha_i+\beta_i
$$
所以有
$$
gcd(a,b)\times lcm(a,b) =p_1^{\alpha_1+\beta_1}\cdot p_2^{\alpha_2+\beta_2}\cdot\cdot\cdot p_s^{\alpha_s+\beta_s}</h1>
<p>a\times b
$$</p>
</li>
</ul>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="基础数论"></category>
  </entry>
  <entry>
    <title>Dijkstra单源最短路朴素算法</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-17-dijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-17-dijkstra%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95/</id>
    <published>2024-12-17T00:00:00.000Z</published>
    <updated>2024-12-17T00:00:00.000Z</updated>
    <summary>计算一个点到到其他节点的最短路径的方法</summary>
    <content type="html"><![CDATA[<p>Dijkstra单源最短路朴素算法</p>
<p>基于无优化的朴素算法，这里使用邻接矩阵的方法存储路径（空间复杂度高）</p>
<h3>Dijkstra单源最短路的算法原理如下：</h3>
<p>从起始点<code>s</code>开始，每次依据贪心选取<strong>最近连通点且未被访问过的点</strong>，移动到该点上，更新最短路径，直到把所有点都访问完</p>
<p>初始化时，需要将<code>s</code>起始点到所有点的<code>dis[i]</code>距离，赋值为极大值，表示不能连通从<code>s</code>出发</p>
<pre><code>for (int i = 0; i &lt;= n; i++)
		dis[i] = 1e9;
</code></pre>
<p>枚举当前能连通的所有点，<strong>记录最短路径点</strong><code>min_node</code>（初始化为0），如果不能更新最短路径点，则说明遍历完了所有的点</p>
<p>有：</p>
<pre><code>if (min_node == 0) break;
</code></pre>
<p>并对其进行标记，表示以及被访问过了</p>
<pre><code>vis[min_node] = 1;
</code></pre>
<p>遍历所有点，<strong>更新</strong>最短路径：</p>
<pre><code>for (int i = 1; i &lt;= n; i++)
	if (dis[i] &gt; dis[min_node] + g[min_node][i])
		dis[i] = dis[min_node] + g[min_node][i];//如果当前点可以组成更短的路径，那就更新
//或写成
for (int i = 1; i &lt;= n; i++)
		dis[i] = min(dis[i], dis[min_node] + g[min_node][i]);
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202412/3529184-20241217165404706-233617666.png" alt="" /></p>
<p>以上图为例：有参数如下</p>
<pre><code>4 6 1 // 四个节点，六条边，从一号点开始

1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
</code></pre>
<p>&lt;u&gt;我们来逐步推导一遍&lt;/u&gt;</p>
<p><strong>初始化：<code>dis[]={1e9, 0, 1e9, 1e9, 1e9}</code></strong></p>
<p><strong>第一轮：</strong></p>
<p>遍历所有未访问的点，$1$号点到自身的路径为 $0$，为最短，<code>min_node</code>为$1$</p>
<p>标记$1$号点，接着遍历所有节点并更新路径为：<code>dis[]={1e9, 0, 2, 5, 4}</code></p>
<p><strong>第二轮：</strong></p>
<p>遍历所有未访问的点，$2$号点到$1$号点的路径为 $2$，为最短，<code>min_node</code>为$2$</p>
<p>标记$2$号点，接着遍历所有节点并更新路径为：<code>dis[]={1e9, 0, 2, 4, 3}</code></p>
<p><strong>第三轮：</strong></p>
<p>遍历所有未访问的点，$4$号点到$1$号点的路径为 $3$，为最短，<code>min_node</code>为$4$</p>
<p>标记$4$号点，接着遍历所有节点并更新路径为：<code>dis[]={1e9, 0, 2, 4, 3}</code></p>
<p><strong>第四轮：</strong></p>
<p>遍历所有未访问的点，$3$号点到$1$号点的路径为 $4$，为最短，<code>min_node</code>为$3$</p>
<p>标记$4$号点，接着遍历所有节点并更新路径为：<code>dis[]={1e9, 0, 2, 4, 3}</code></p>
<p><strong>第五轮：</strong></p>
<p><strong>遍历所有未访问的点，可以发现所有的点都被遍历过了，于是退出循环</strong></p>
<hr />
<p>Dijkstra是一种基于贪心的最短路径算法，但是他不能处理存在负边权的情况，这是因为<strong>如果存在负权边，那就有可能先通过不是距起始点最近的一个次优点，再通过这个负权边，使得路径之和更小</strong>
<img src="https://img2024.cnblogs.com/blog/3529184/202412/3529184-20241217165422699-1995000166.png" alt="" /></p>
<p><strong>如上图所示，从<code>S</code>点出发，贪心会选择<code>S -&gt; B</code>，而不是全局最优的<code>S -&gt; A -&gt; B</code>，这就发生了错误</strong></p>
<ul>
<li>&lt;u&gt;贪心的正确性这里不做赘述，详情可自行查看：&lt;/u&gt;</li>
</ul>
<p><a href="https://oi-wiki.org/graph/shortest-path/#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E">最短路 - OI Wiki</a></p>
<p>朴素算法如下：</p>
<pre><code>bool vis[N];
int dis[N];
int g[N][N];//邻接矩阵存储路径

void dijkstra(int s) {
	for (int i = 0; i &lt;= n; i++)
		dis[i] = 1e9;//赋值极大值
	dis[s] = 0;//起始点被访问过
	while (true)
	{
		int min_node = 0, min_mem = 1e9;
		for (int i = 1; i &lt;= n; i++) {
			if (!vis[i] &amp;&amp; min_mem &gt; dis[i])
			{
				min_node = i;
				min_mem = dis[i];
			}
		}//找到最短路径点，记录编号
		
		if (min_node == 0) break;
		vis[min_node] = 1;
		for (int i = 1; i &lt;= n; i++)
			if (dis[i] &gt; dis[min_node] + g[min_node][i])
				dis[i] = dis[min_node] + g[min_node][i];
	}
}
</code></pre>
<hr />
<p>基于使用邻接表存储连接边的方法，可以有效的降低空间复杂度</p>
<p>在<strong>稀疏图</strong>（边的数量远小于顶点数量平方的图）中，邻接矩阵会大量占用无用的内存，导致<code>Re</code>，我们采用邻接表的办法，只存储存在的边，减少无关占用。相反，在<strong>稠密图</strong>（边的数量接近顶点数的平方的图）中，邻接表会遍历一整条链，检索时间会大大增加（不做优化），我们就采取邻接矩阵的方法来存储，每次只需要通过下标快速检索</p>
<p><strong>通过结构体和<code>vector</code>来构造边的链表</strong></p>
<pre><code>struct edge
{
	int v, w;//v表示连接到的节点，w表示边权重
};
vector&lt;edge&gt; e[10010];
</code></pre>
<p>插入边操作</p>
<pre><code>void insert(int u, int v, int w) {
	e[u].push_back({ v,w });
}

cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
insert(u, v, w);
</code></pre>
<p>然后是使用<strong>朴素</strong>的Dijkstra算法实现单源最短路</p>
<pre><code>void dijkstra(int s) {
	memset(dis, 0x3f, sizeof dis);//初始化可以使用memset 0x3f 批量操作
	dis[s] = 0;//起始点被访问
	for (int i = 1; i &lt;= n; i++) {
		int min_node = 0;//初始化

		for (int j = 1; j &lt;= n; j++)//遍历所有点
			min_node = dis[j] &lt; dis[min_node] &amp;&amp; !vis[j] ? j : min_node;
//找未被访问过的点中的最近点，判断最小值
		
		if (!min_node) break;//如果没能找到，即min_node未更新，退出循环
		vis[min_node] = 1;//当前点已被访问过

		for (auto it = e[min_node].begin(); it != e[min_node].end(); it++)//迭代器遍历当前点的所有连通边
			dis[it-&gt;v] = min(dis[min_node] + it-&gt;w, dis[it-&gt;v]);//更新最小值
	}
}
</code></pre>
<p>使用迭代器遍历时，<strong>需要通过箭头运算符 <code>-&gt;</code> 来访问结构体的成员元素</strong></p>
<pre><code>for (auto it = e[min_node].begin(); it != e[min_node].end(); it++)
	dis[it-&gt;v] = min(dis[min_node] + it-&gt;w, dis[it-&gt;v]);
</code></pre>
<p>同样也可使用C++11标准内的<strong>区间遍历</strong></p>
<pre><code>for (auto iter : e[min_node])
	dis[iter.v] = min(dis[min_node] + iter.w, dis[iter.v]);
</code></pre>
<p>区间遍历的一般格式</p>
<pre><code>for (dataType rangeVariable : array) 
</code></pre>
<p><code>dataType</code>为需要遍历的数组的数据类型，<code> rangeVariable</code>为循环内范围变量的名称，该变量用来<strong>接收遍历元素的值</strong>，<code>array</code>为需要遍历的数组名，<strong>区间遍历的范围变量只需要通过 <code>.</code> 就能访问结构的成员元素</strong></p>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
  <entry>
    <title>Floyd多源最短路算法</title>
    <link href="https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-16-floyd%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html"/>
    <id>https://mizuki.mysqil.com/posts/%E5%9B%BE%E8%AE%BA/2024-12-16-floyd%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</id>
    <published>2024-12-16T00:00:00.000Z</published>
    <updated>2024-12-16T00:00:00.000Z</updated>
    <summary>一种批量求最短路算法</summary>
    <content type="html"><![CDATA[<p>使用Floyd（弗洛伊德）算法，可以以 $O(n^3)$ 的时间复杂度求出一张多源图的<strong>任意两点间的最短路径</strong></p>
<h3>一般采用<strong>邻接矩阵</strong>的方法来存储图：</h3>
<pre><code>int g[N][N];
g[i][j]
</code></pre>
<p>其中，<code>g[i][j]</code>的意义为第<code>i</code>个节点到第<code>j</code>个节点的权重</p>
<p>我们需要对邻接矩阵进行路径初始化，<strong>将自身到自身的权重设置为 $0$ ，到其他节点的距离初始化为 $+\infty$（或极大的一个值）</strong></p>
<pre><code>for (int i = 0; i &lt;= N; i++)
	for (int j = 0; j &lt;= N; j++)
		if (i == j) g[i][j] = 0;
		else g[i][j] = 1e9;
</code></pre>
<p>对有向图而言，我们通过三个参数进行边的读入：</p>
<pre><code>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
g[u][v] = min(g[u][v], w);//判断重边
</code></pre>
<p>如果是无向图，则只需要再次赋值反向边即可</p>
<pre><code>g[u][v] = g[v][u] = min(g[u][v], w);
</code></pre>
<hr />
<h3>Floyd算法原理：</h3>
<p>对任意两个节点<code>a,b</code>而言，如果存在有更短的路径连通它们两个，则必然存在另外一个节点<code>c</code>，使得：</p>
<pre><code>g[a][b] &lt; g[a][c] + g[c][a]
</code></pre>
<p>换言之，如果需要更新我们的最短路径，就需要额外的<strong>一个中转节点</strong>来加入我们的路径中</p>
<p><img src="https://img2024.cnblogs.com/blog/3529184/202412/3529184-20241216135124455-1569465130.png" alt="" /></p>
<p>同样的，如果对经过三个节点的路径<code>a,b,c</code>，能更新一个更短的路径，就需要加入<code>d</code>节点</p>
<p>不难写出以下代码：<strong>其中，我们的 <code>k</code> 为新加入的节点</strong></p>
<pre><code>for (int i = 1; i &lt;= N; i++)
	for (int j = 1; j &lt;= N; j++)
		g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
</code></pre>
<p>每次遍历两层所有节点，目的是更新每个节点间的最短路径，并<strong>判断能否通过新加入的 <code>k</code> 节点，得到一个更短路径</strong></p>
<p><strong>我们的 <code>k</code>节点可以取到所有的节点来作为路径中转</strong>
因为相对于任意两个节点，我们都能够使用其余的节点来构建出一条<strong>经过任意多的中转节点的最短路径</strong></p>
<p>于是有最终的递推函数，求得最短路：</p>
<pre><code>void floyd(void) {
	for (int k = 1; k &lt;= N; k++)
		for (int i = 1; i &lt;= N; i++)
	        for (int j = 1; j &lt;= N; j++)
		        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
}
</code></pre>
<p>**注意：**Floyd算法不能对存在负环的图使用，如果存在负环，每次取路径的<code>min</code>时，都会取到更小的负数，导致无法正确退出循环</p>
<p>以洛谷B3647为例：</p>
<p><strong>输出最终的邻接矩阵</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int n, m;
int g[105][105];

void floyd(void) {
	for (int k = 1; k &lt;= N; k++)
		for (int i = 1; i &lt;= N; i++)
	        for (int j = 1; j &lt;= N; j++)
		        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
}

int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	int u, v, w;
	for (int i = 0; i &lt;= n; i++)
		for (int j = 0; j &lt;= n; j++)
			if (i != j) g[i][j] = 1e9;
	for (int i = 0; i &lt; m; i++) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		g[u][v] = g[v][u] = min(g[u][v], w);
	}
	floyd();
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= n; j++)
			cout &lt;&lt; g[i][j] &lt;&lt; ' ';
		cout &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
]]></content>
    <author>
      <name>才瓯</name>
    </author>
    <category term="图论"></category>
  </entry>
</feed>