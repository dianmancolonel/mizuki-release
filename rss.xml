<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Unkai-Saiou</title><description>One demo website</description><link>https://mizuki.mysqil.com/</link><language>zh_CN</language><item><title>FWT 快速沃尔什变换</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-11-fwt_%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-11-fwt_%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</guid><description>FWT快速沃尔什变换应用计算方案数量</description><pubDate>Mon, 11 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;FWT 快速沃尔什变换&lt;/p&gt;
&lt;p&gt;对于整数数组进行位运算卷积的快速计算方式，和 FFT 类似的时间复杂度 $O(n\log n)$&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;引入&lt;/h3&gt;
&lt;p&gt;位运算卷积：$C_i=\sum\limits_{i=j\otimes k} A_jB_k$ ，其中 $\otimes $ 表示某种位运算操作&lt;/p&gt;
&lt;p&gt;正变换：通过 $A,B$ 序列计算 $f(A),f(B)$ ，然后进行运算 $f(C)=f(A)\cdot f(B)$&lt;/p&gt;
&lt;p&gt;逆变换：通过 $f(C)$ 得到原序列 $C$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义 $f$ 函数的原则是需要满足 $f(A)=f(B)\cdot f(C)$&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;或运算&lt;/h3&gt;
&lt;p&gt;设 $k=i\cup j$ ，那么 $i,j$ 的二进制位为 $1$ 的位置一定也是 $k$ 的二进制为 $1$ 的位置的子集&lt;/p&gt;
&lt;p&gt;定义 $A=a_0,a_1,\cdots a_n$ 表示序列 $A$ 的多项式函数的系数，$f(A)&lt;em&gt;i=\sum\limits&lt;/em&gt;{i=i\cup j}A_j$ 则表示 $j$ 满足二进制中 $1$ 为 $i$ 的子集&lt;/p&gt;
&lt;p&gt;检验：
$$
f(B)&lt;em&gt;i\cdot f(C)&lt;em&gt;i=\left(\sum\limits&lt;/em&gt;{i=i\cup j}B_j\right)\cdot \left(\sum\limits&lt;/em&gt;{i=i\cup k}C_k\right)=\sum\limits_{i=i\cup j}\sum\limits_{i=i\cup k}A_jB_k
$$
$$
=\sum\limits_{i=i\cup (j\cup k)}A_jB_k=f(c)_i
$$
枚举的时间复杂度是 $O(n^2)$ ，可以通过分治优化到 $O(n\log n)$&lt;/p&gt;
&lt;p&gt;对形式化的多项式 $A(x)$ 而言，设它的最高次为 $2^n$ ，将其拆分为 $A_0,A_1$ 两个部分，最高次都为 $2^{n-1}$&lt;/p&gt;
&lt;p&gt;有关或运算卷积的正变换计算可以被表示为：
$$
f(A)=merge\left[f(A_0),f(A_0)+f(A_1)\right]
$$
&lt;strong&gt;因为前半部分的 $A_0$ 一定不包含 $A_1$ 的最高位 $1$ ，所以 $f(A)$ 的前半部分只与 $f(A_0)$ 有关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$merge$ 操作相当于把两个多项式直接连接起来&lt;/p&gt;
&lt;p&gt;同样的有逆变换：
$$
f^{-1}(A)=merge\left[f^{-1}(A_0),f(A_1)^{-1}-f^{-1}(A_0)\right]
$$
采用&lt;strong&gt;迭代&lt;/strong&gt;的方式，集成正逆变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void FWTOR(LL a[],int op){
	for (int d=2;d&amp;lt;=(1&amp;lt;&amp;lt;m);d&amp;lt;&amp;lt;=1){//枚举分块数
		int k=d&amp;gt;&amp;gt;1;//分治
		for (int i=0;i&amp;lt;(1&amp;lt;&amp;lt;m);i+=d){
			for (int j=0;j&amp;lt;k;j++){//块内运算
				(a[i+j+k]+=a[i+j]*op)%=mod;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;与运算&lt;/h3&gt;
&lt;p&gt;类比或运算可以得到相应运算：
$$
f(A)=merge\left[f(A_0)+f(A_1),f(A_0)\right]
$$
$$
f^{-1}(A)=merge\left[f^{-1}(A_0)-f^{-1}(A_0),f(A_1)\right]
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void FWTAND(LL a[],int op){
	for (int d=2;d&amp;lt;=(1&amp;lt;&amp;lt;m);d&amp;lt;&amp;lt;=1){
		int k=d&amp;gt;&amp;gt;1;
		for (int i=0;i&amp;lt;(1&amp;lt;&amp;lt;m);i+=d){
			for (int j=0;j&amp;lt;k;j++){
				(a[i+j]+=a[i+j+k]*op)%=mod;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;异或运算&lt;/h3&gt;
&lt;p&gt;定义 $x\circ y=\mathrm{popcnt}(x\cap y)\ (\mathrm{mod}\ 2)$  表示 $x\cap y$ 中二进制 $1$ 的个数，所以有 $(x\circ y)\mathrm{xor}(x\circ z)=x\circ(y\ \mathrm{xor}\ z)$&lt;/p&gt;
&lt;p&gt;设 $f(A)&lt;em&gt;i=\sum\limits&lt;/em&gt;{i\circ j=0}A_j-\sum\limits_{i\circ j=1}A_j$ ，检验：
$$
f(B)&lt;em&gt;i\cdot f(C)&lt;em&gt;i=\left(\sum\limits&lt;/em&gt;{i\circ j=0}B_j -\sum\limits&lt;/em&gt;{i\circ j=1}B_j\right)\left(\sum\limits_{i\circ k=0}C_k -\sum\limits_{i\circ k=1}C_k\right)
$$
$$
=\left(\sum\limits_{i\circ j=0}B_j \sum\limits_{i\circ k=0}C_k+\sum\limits_{i\circ j=1}B_j \sum\limits_{i\circ k=1}C_k\right)-\left(\sum\limits_{i\circ j=0}B_j \sum\limits_{i\circ k=1}C_k+\sum\limits_{i\circ j=1}B_j \sum\limits_{i\circ k=0}C_k\right)
$$
$$
=\sum\limits_{(j\ \mathrm{xor}\ k)\circ i=0}B_jC_k-\sum\limits_{(j\ \mathrm{xor}\ k)\circ i=1}B_jC_k=f(c)_i
$$
正逆变换计算：
$$
f(A)=merge\left[ f(A_0)+f(A_1),f(A_0)-f(A_1) \right]
$$
$$
f^{-1}(A)=merge\left[ \frac{f^{-1}(A_0)+f^{-1}(A_1)}{2},\frac{f^{-1}(A_0)-f^{-1}(A_1)}{2}\right]
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void FWTXOR(LL a[],int op){
	for (int d=2;d&amp;lt;=(1&amp;lt;&amp;lt;m);d&amp;lt;&amp;lt;=1){
		int k=d&amp;gt;&amp;gt;1;
		for (int i=0;i&amp;lt;(1&amp;lt;&amp;lt;m);i+=d){
			for (int j=0;j&amp;lt;k;j++){
				(a[i+j]+=a[i+j+k])%=mod;
				(a[i+j+k]=a[i+j]-a[i+j+k]*2)%=mod;
				(a[i+j]*=op)%=mod;
				(a[i+j+k]*=op)%=mod;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;注意到的是，在函数执行过程中可能存在对负数取模的场景&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(a[i+j+k]+=a[i+j]*op)%=mod;//op=-1时
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为了降低常数我们不在过程中取模而是统一在全部计算后再依次取正数模&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i=0;i&amp;lt;n;i++)
    if (a[i]&amp;lt;0) a[i]+=mod;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;FMT 快速莫比乌斯变换优化&lt;/h3&gt;
&lt;p&gt;莫比乌斯变换：定义 $f,g$ 是全集 $U$ 上的任意一个子集的函数，若：
$$
f(S)=\sum\limits_{S=S\cup T} g(T)
$$
则有：
$$
g(S)=\sum\limits_{S=S\cup T} (-1)^{\lvert S\rvert-\lvert T\rvert} f(T)
$$
证明：
$$
\begin{aligned}
\sum_{T \subseteq S} (-1)^{|S|-|T|} f(T)
&amp;amp;= \sum_{T \subseteq S} (-1)^{|S|-|T|} \sum_{I \subseteq T} g(I) \
&amp;amp;= \sum_{I \subseteq S} g(I) \sum_{I \subseteq T,, T \subseteq S} (-1)^{|S|-|T|} \
&amp;amp;= \sum_{I \subseteq S} g(I) \sum_{T \subseteq S \setminus I} (-1)^{|S \setminus I| - |T|} \
&amp;amp;= \sum_{I \subseteq S} g(I) \sum_{k=0}^{|S \setminus I|} \binom{|S \setminus I|}{k} (-1)^{|S \setminus I| - k} \
&amp;amp;= \sum_{I \subseteq S} g(I) \cdot 0^{|S \setminus I|} \
&amp;amp;= g(S)
\end{aligned}
$$
&lt;strong&gt;在某些场景下，我们可能并不需要逆变换后 $C$ 的每一项系数，而是只需要其中某一项次数为 $k$ 的系数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对 $f(C)$ 进行逆变换的时间复杂度为 $O(n\log n)$ ，利用 FMT/容斥原理 可以在 $O(\log n)$ 的时间复杂度内计算出某一项的系数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LL sum=0;
for (int i=0;i&amp;lt;n;i++){
	if (__builtin_popcount(n-1-i)&amp;amp;1) sum-=A[i];//这里的n-1是二进制全1的数
	else sum+=A[i];
	sum=(sum+mod)%mod;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>FFT 快速傅里叶变换</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-08-ftt_%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-08-08-ftt_%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</guid><description>FFT快速傅里叶变换的应用，优化高精度乘法</description><pubDate>Fri, 08 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;FTT 快速傅里叶变换&lt;/p&gt;
&lt;p&gt;高效实现 DFT 离散傅里叶变换的一种手段，可以将两个 $n$ 次多项式相乘的时间复杂度优化到 $O(n\log n)$ 的算法&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;**引理：**给定 $n$ 个点可以确定 $n-1$ 次函数曲线的系数和系数存在映射关系&lt;/p&gt;
&lt;p&gt;设两个多项式分别为 $F(x),G(x)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过这两个多项式的系数经过&lt;strong&gt;系数乘法&lt;/strong&gt;可以计算出 $F(x)\cdot G(x)$ 的系数，基于单位圆划分出 $n$ 个点，通过计算得到的这 $n$ 个点值，我们就能&lt;strong&gt;唯一确定&lt;/strong&gt;函数 $F(x)\cdot G(x)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于单位圆划分出 $n$ 个点，计算这两个多项式的这 $n$ 个点值，再利用&lt;strong&gt;点值乘法&lt;/strong&gt;确定函数 $F(x)\cdot G(x)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;strong&gt;单位圆&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2024.cnblogs.com/blog/3529184/202508/3529184-20250808203357817-435762157.png&quot; alt=&quot;image-20250807220538390&quot; /&gt;&lt;/p&gt;
&lt;p&gt;复平面的单位元圆上的点都可以被表示为：
$$
z=\cos \theta +i\sin \theta\  (0\le \theta &amp;lt; 2\pi)
$$
把单元圆 $n$ 等分（$n=2^{b\in N^+}$），可以得到方程 $z^n=1$ 的 $n$ 个复数根 $\omega_n$ ，单位根为：
$$
\omega_n^k=\cos \frac{2\pi k}{n}+i\sin\frac{2\pi k}{n}
$$
满足性质有：$\omega _n^k\cdot \omega_n^m=\omega_n^{k+m},(\omega _n^k)^m=\omega _n^{km}$ ，周期性：$\omega _n^{k+n}=\omega _n^k$ ，对称性：$\omega _n^{k+\frac{n}{2}}=-\omega _n^k$ ，折半性：$\omega _n^{2k}=\omega _{\frac{n}{2}}^k$&lt;/p&gt;
&lt;h3&gt;正变换&lt;/h3&gt;
&lt;p&gt;通过多项式 $A(x)$ 的系数求点值，设系数为 $a_0,a_1,\cdots,a_{n-1}$ ，则 $A(x)$ 被表示为：
$$
A(x)=a_0+a_1x+a_2x^2+\cdots +a_{n-1} x^{n-1}
$$
将奇次项和偶次项分离后有：
$$
A(x)=(a_0+a_2x^2+\cdots +a_{n-2}x^{n-2})+(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2})x
$$
分别设 $A_0(x),A_1(x)$ 为：
$$
A_0(x)=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{\frac{n}{2}-1}
$$
$$
A_1(x)=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{\frac{n}{2}-1}
$$
$$
A(x)=A_0(x^2)+A_1(x^2)x
$$
将 $$x=\omega &lt;em&gt;n^k\ (k&amp;lt;\frac{n}{2})$$ 代入得：
$$
A(\omega_n^k)=A_0(\omega_n^{2k})+A_1(\omega_n^{2k})\omega_n^k=A_0(\omega&lt;/em&gt;\frac{n}{2}^{k})+A_1(\omega_\frac{n}{2}^{k})\omega_n^k
$$
同理代入 $$x=\omega &lt;em&gt;n^{k+\frac{n}{2}}\ (k&amp;lt;\frac{n}{2})$$
$$
A(\omega_n^{k+\frac{n}{2}})=A_0(\omega_n^{2k+n})+A_1(\omega_n^{2k+n})\omega_n^{k+\frac{n}{2}}=A_0(\omega&lt;/em&gt;\frac{n}{2}^{k})-A_1(\omega_\frac{n}{2}^{k})\omega_n^{k}
$$
在求出 $A_0(\omega _n^k),A_1(\omega _n^k)$ 后我们就能&lt;strong&gt;同时得到&lt;/strong&gt; $A(\omega _n^k),A(\omega _n^{k+\frac{n}{2}})$ ，所以对 $A_0,A_1$ 分别进行递归求解&lt;/p&gt;
&lt;p&gt;特别的，基于分治 FFT 处理的多项式长度只能是 $2^{b\in N^+}$ ，所以对于不是二整数次幂的形式，都需要补齐再计算&lt;/p&gt;
&lt;h3&gt;逆变换&lt;/h3&gt;
&lt;p&gt;通过多项式 $A(x)$ 的点值求系数，设代入 $\omega _n^0,\omega &lt;em&gt;n^1,\cdots,\omega &lt;em&gt;n^{n-1}$ 得到的点值为 $y_0,y_1,\cdots,y&lt;/em&gt;{n-1}\ (y_i=\sum\limits&lt;/em&gt;{j=0}^{n-1} a_j(\omega_n^i)^j)$&lt;/p&gt;
&lt;p&gt;构造多项式 $B(x)$：
$$
B(x)=y_0+y_1x+\cdots+y_{n-1}x^{n-1}
$$
将单位根的倒数 $\omega &lt;em&gt;n^0,\omega &lt;em&gt;n^{-1},\cdots,\omega &lt;em&gt;n^{-(n-1)}$
$$
\omega &lt;em&gt;n^k=\cos \theta +i\sin \theta\
\frac{1}{\omega &lt;em&gt;n^k}=\frac{1}{\cos \theta +i\sin \theta}=\cos \theta -i\sin \theta=\cos (-\theta) +i\sin (-\theta)
$$
代入 $B(x)$ 得到新点值为 $z_0,z_1,\cdots,z&lt;/em&gt;{n-1}$，其中：
$$
z_k=\sum\limits&lt;/em&gt;{i=0}^{n-1} y_i(\omega_n^{-k})^i=\sum\limits&lt;/em&gt;{i=0}^{n-1}\sum\limits&lt;/em&gt;{j=0}^{n-1} a_j(\omega_n^i)^j(\omega_n^{-k})^i=\sum\limits&lt;/em&gt;{j=0}^{n-1}a_j\sum\limits_{i=0}^{n-1}(\omega_n^{j-k})^i
$$
$$
\sum\limits_{i=0}^{n-1}(\omega_n^{j-k})^i=&lt;/p&gt;
&lt;p&gt;\left{
\begin{array}{l}
\sum\limits_{i=0}^{n-1}1=n &amp;amp; j=k\
(\omega_n^{j-k})^n=(\omega_n^n)^{j-k}=0 &amp;amp; j\ne k
\end{array}
\right.
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以 $z_k=na_k$ ，通过 $\omega_n^{-k}$ 确定的点值逆变换后可以确定原函数的系数&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;基于递归实现的 FFT&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void FFT(vector&amp;lt;complex&amp;lt;double&amp;gt;&amp;gt; &amp;amp;A,int n,int op){
	if (n==1) return;
	vector&amp;lt;complex&amp;lt;double&amp;gt;&amp;gt; A0(n/2),A1(n/2);
	for (int i=0;i&amp;lt;n/2;i++)
		A0[i]=A[i*2],A1[i]=A[i*2+1];
	FFT(A0,n/2,op),FFT(A1,n/2,op);
	complex&amp;lt;double&amp;gt; w1({cos(2*PI/n),sin(2*PI/n)*op});
	complex&amp;lt;double&amp;gt; wk({1,0});
	for (int i=0;i&amp;lt;n/2;i++){
		A[i]=A0[i]+A1[i]*wk;
		A[i+n/2]=A0[i]-A1[i]*wk;
		wk=wk*w1;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;op&lt;/code&gt; 参数表示当前执行的是正变换还是逆变换，区别在于对 $\omega_n^k$ 的符号控制&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;基于迭代实现的 FFT&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2024.cnblogs.com/blog/3529184/202508/3529184-20250808203408818-443987858.png&quot; alt=&quot;image-20250808142932444&quot; /&gt;&lt;/p&gt;
&lt;p&gt;原序列分治到底层后变换的序列存在一个规律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个数用二进制表示，将二进制翻转对称一下，就是最终那个位置的下标，例如 $a_0=001_2,a_4=100_2$ ，我们称这个变换为位逆序置换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据定义的方法，我们可以在 $O(n\log n)$ 的时间复杂度内求出每个数变换后的结果&lt;/p&gt;
&lt;p&gt;事实上，还可以通过 $O(n)$ 的递推时间复杂度实现，设 $n=2^k$ ，$k$ 表示二进制数的长度&lt;/p&gt;
&lt;p&gt;设 $R_x$ 为长度为 $k$ 的二进制数 $x$ 翻转后的结果，存在这样的递推关系：
$$
R_x=\frac{R_{\frac{x}{2}}}{2} +(x\ \mathrm{mod}\ 2)\times \frac{n}{2}
$$
从小到大求 $R_x$ ，$R_{\frac{x}{2}}$ 的值已知。把 $x$ &lt;strong&gt;除以二（右移一位）然后翻转再除以二&lt;/strong&gt;，就得到了 $x$ 除开二进制个位之外其他位翻转的结果，再单独考虑二进制个位的影响，如果翻转前个位是 $1$ ，那么翻转后的最高位也为 $1$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void change(vector&amp;lt;complex&amp;lt;double&amp;gt;&amp;gt; &amp;amp;A,int n){
	vector&amp;lt;int&amp;gt; R(n,0);
	for (int i=0;i&amp;lt;n;i++)
		R[i]=(R[i&amp;gt;&amp;gt;1]&amp;gt;&amp;gt;1)+((i&amp;amp;1)?(n&amp;gt;&amp;gt;1):0);
	for (int i=0;i&amp;lt;n;i++)
		if (i&amp;lt;R[i]) swap(A[i],A[R[i]]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用位逆序变换得到后序列，然后自底向上合并&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void FFT(vector&amp;lt;complex&amp;lt;double&amp;gt;&amp;gt; &amp;amp;A,int n,int op){
	change(A,n);
	for (int m=2;m&amp;lt;=n;m&amp;lt;&amp;lt;=1){//枚举分治块的长度
		complex&amp;lt;double&amp;gt; w1({cos(2*PI/m),sin(2*PI/m)*op});
		for (int i=0;i&amp;lt;n;i+=m){//枚举块的个数
			complex&amp;lt;double&amp;gt; wk({1,0});
			for (int j=0;j&amp;lt;m/2;j++){//
				complex&amp;lt;double&amp;gt; x=A[i+j],y=A[i+j+m/2]*wk;
				A[i+j]=x+y;
				A[i+j+m/2]=x-y;
				wk=wk*w1;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;优化高精度乘法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void solve(){
	string sa,sb;
	cin&amp;gt;&amp;gt;sa&amp;gt;&amp;gt;sb;
	int n=sa.size(),m=sb.size();
	for (int i=n-1;i&amp;gt;=0;i--) a[n-i-1]=sa[i]-&apos;0&apos;;
	for (int i=m-1;i&amp;gt;=0;i--) b[m-i-1]=sb[i]-&apos;0&apos;;
	int nm=n+m;
	for (n=1;n&amp;lt;=nm;n&amp;lt;&amp;lt;=1);
	FFT(a,n,1),FFT(b,n,1);
	for (int i=0;i&amp;lt;n;i++) ab[i]=a[i]*b[i];
	FFT(ab,n,-1);
	vector&amp;lt;int&amp;gt; ans;
	for (int i=0,t=0;i&amp;lt;n;i++){
		t+=(ab[i].real()/n+0.5);
		ans.push_back(t%10);
		t/=10;
	}
	while (ans.size()&amp;gt;1&amp;amp;&amp;amp;ans.back()==0) ans.pop_back();
	for (int i=ans.size()-1;i&amp;gt;=0;i--) cout&amp;lt;&amp;lt;ans[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将十进制数看作一个 $x=10$ 的函数 $A(x)$ ，每个系数 $a_{i}$ 表示第 $i+1$ 位上的数&lt;/p&gt;
&lt;p&gt;同样的，将读入的两个数 $a,b$ 转化为数组存储后利用 FFT 计算出点值，然后通过点值乘法计算 $a\times b$ 映射的点值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再通过 FFT 逆变换计算出系数，最后按位取模得到拆分下来的十进制的每一位&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>威尔逊定理、裴蜀定理</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-27-%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-27-%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</guid><description>威尔逊定理和裴蜀定理的基本概念与应用</description><pubDate>Sun, 27 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;威尔逊定理&lt;/h3&gt;
&lt;p&gt;判定整数 $p$ 为质数的充分必要条件是：
$$
(p-1)!\equiv -1 (\mathrm{mod}\ p)
$$
&lt;strong&gt;充分性证明：当 $p$ 不为质数时&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$p$ 可以被表示为完全平方数，即 $p=k^2$&lt;/p&gt;
&lt;p&gt;当 $k&amp;gt;2$ 时，显然有 $2k&amp;lt;p=k^2$，则 $(p-1)!=1\times2\times\cdots\times k\times \cdots \times 2k\times\cdots \times (p-1)$&lt;/p&gt;
&lt;p&gt;提出 $k,2k$ 得 $(p-1)!=k^2\times \alpha=p\times \alpha$ ，那么 $(p-1)!\equiv 0(\mathrm{mod}\ p)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$p$ 不是完全平方数，即 $p=a\times b\ (a\ne b)$&lt;/p&gt;
&lt;p&gt;令 $1&amp;lt;a&amp;lt;b&amp;lt;p$ ，则 $(p-1)!=1\times2\times\cdots\times a\times \cdots \times b\times\cdots \times (p-1)$&lt;/p&gt;
&lt;p&gt;提出 $a,b$ 得 $(p-1)!=a\times b\times \alpha=p\times \alpha$ ，那么 $(p-1)!\equiv 0(\mathrm{mod\ }p)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;必要性证明：当 $p$ 为质数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;质数 $p$ 的简化剩余系为 ${1,2,\cdots,(p-1)}$ ，模意义下的逆元形式为 $ax\equiv 1(\mathrm{mod\ }p)$&lt;/p&gt;
&lt;p&gt;**引理：**对于模 $m$ 的简化剩余系中每个元素 $a$ 都存在唯一元素 $x$（&lt;strong&gt;也在同一简化剩余系内&lt;/strong&gt;） 满足 $ax\equiv 1(\mathrm{mod\ }m)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $a=x$ 时，有 $x^2 \equiv 1(\mathrm{mod\ }p)$ ，分解得到 $(x-1)(x+1)\equiv 0(\mathrm{mod\ }p)$ 。则 $a=x=1,(p-1)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 $a\ne x$ 时，满足 $ax\equiv 1(\mathrm{mod\ }p)$ 的 $(a,x)$ 从 $[2,p-2]$ 的集合中取得，必然存在 $\frac{p-3}{2}$ 对不同的 $(a,x)$ 使得同余式成立&lt;/p&gt;
&lt;p&gt;即 $(p-2)!\equiv 1(\mathrm{mod\ }p)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$(p-2)!\equiv 1 (\mathrm{mod}\ p)$ 在同余式两侧都乘上 $p-1$ 后，有 $(p-1)!\equiv 1(\mathrm{mod\ }p)$ ，证毕&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推论：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若正整数 $p$ 为质数，则 $(p-1)!+1\equiv 0(\mathrm{mod\ }p)$&lt;/li&gt;
&lt;li&gt;若正整数 $p$ 为大于 $4$ 的合数，则 $(p-1)!\equiv 0(\mathrm{mod\ }p)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;裴蜀定理&lt;/h3&gt;
&lt;p&gt;对于给定的整数 $a,b$ 一定存在整数 $x,y$ 满足等式
$$
ax+by=\mathrm{gcd}(a,b)
$$
&lt;strong&gt;证明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设正整数 $x,y,a,b$ 有 $ax+by$ ，设 $x=x_0,y=y_0$ 时有等式 $ax+by=s$ ，其中 $s$ 为满足等式的&lt;strong&gt;最小正整数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;显然存在整除关系：$\mathrm{gcd}(a,b)\mid ax_0\ ,\ \mathrm{gcd}(a,b)\mid by_0$，则 $\mathrm{gcd}(a,b)\mid s$ 也成立&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设 $a=qs+r(0\le r&amp;lt;s)$  即 $a$ 通过 $s$ 的除法余数表示，那么有：
$$
r=a-qs=a-q(ax_0+by_0)\
\implies r=a(1-qx_0)+b(-qy_0)
$$
因为 $q$ 为整数，所以 $(1-qx_0),(-qy_0)$ 也都为整数，那么对于相同的 $a,b$ 上述等式可以被改写为
$$
r=a(1-qx_0)+b(-qy_0)=ax_1+by_1
$$
那么 $r$ 也为形如 $ax+by=s$ 的数，因为 $s$ 是最小正整数解，那么 $r=0$&lt;/p&gt;
&lt;p&gt;所以 $a=qs$ ，则 $s\mid a$ ，同理得到 $s\mid b$ ，故 $s\mid \mathrm{gcd}(a,b)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$\mathrm{gcd}(a,b)\mid s,s\mid \mathrm{gcd}(a,b)$ 同时成立当且仅当 $s= \mathrm{gcd}(a,b)$ ，证毕&lt;/p&gt;
&lt;p&gt;特别的 ，当 $a,b$ 有负数时，计算的 $\mathrm{gcd}(a,b)$ 也为负数，&lt;strong&gt;但由于正负性不改变解，所以可以直接取绝对值计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推广定理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于给定的整数 $a,b$ 一定存在整数 $x,y$ 满足 $ax+by=\mathrm{gcd}(a,b)\times n$ ，$n$ 为正整数&lt;/li&gt;
&lt;li&gt;对于给定的整数集合 $A$ ，一定存在整数 $X$ 集合满足 $\sum A_iX_i=\mathrm{gcd}(A_1,A_2,\cdots,A_n)$&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>同余类、欧拉降幂</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-23-%E5%90%8C%E4%BD%99%E7%B1%BB%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-07-23-%E5%90%8C%E4%BD%99%E7%B1%BB%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82/</guid><description>同余类和欧拉降幂的基本概念与应用</description><pubDate>Wed, 23 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;同余类&lt;/h3&gt;
&lt;p&gt;给定一个正整数 $n$ ，将所有整数依据模 $n$ 的余数 $r\in[0,n-1]$ 分为 $n$ 类，其中每一类都可以被表示为 $C_r=nx+r$ ，一个 $C_r$ 构成的一个集合是模 $n$ 的一个同余类&lt;/p&gt;
&lt;h3&gt;完全剩余系&lt;/h3&gt;
&lt;p&gt;给定一个正整数 $n$ ，有 $n$ 个不同的模 $n$ 的同余类，从这 $n$ 个同余类中各选出一个元素共计 $n$ 个数，这些数构成的一个集合为模 $n$ 的一个完全剩余系。显然对于正整数 $n$ 一定存在一个完全剩余系是 $Z_n=[0,n-1]$ ，该剩余系为简单完全剩余系。同理，对剩余系中任意元素加上 $n$ 的整数倍后得到的集合仍然为模 $n$ 的一个完全剩余系&lt;/p&gt;
&lt;h3&gt;简化剩余系&lt;/h3&gt;
&lt;p&gt;给定一个正整数 $n$ ，有 $\varphi(n)$ 个不同的模 $n$ 的余数 $r$ 与 $n$ 互质的同余类，在这 $\varphi(n)$ 个同余类中各选出一个元素共计 $\varphi(n)$ 个数，这些数构成的一个集合是模 $n$ 的一个简化剩余系。其中 $\varphi(n)$ 为 $n$ 的欧拉函数
$$
\varphi(n)=n\times \prod_{i=1}^s \frac{p_i-1}{p_i}
$$&lt;/p&gt;
&lt;h3&gt;欧拉定理&lt;/h3&gt;
&lt;p&gt;若 ${\rm{gcd}}(a,m)=1$，则 $a^{\varphi(m)} \equiv 1({\rm{mod}}\ m)$&lt;/p&gt;
&lt;p&gt;简单证明：&lt;/p&gt;
&lt;p&gt;设 ${r_1,r_2,\cdots ,r_{\varphi(m)} }$ 是一个模 $m$ 的简化剩余系，则 ${ar_1,ar_2,\cdots,ar_{\varphi(m)} }$ 也是模 $m$ 的一个简化剩余系，所以有
$$
\prod_{i=1}^{\varphi(m)} r_i\equiv \prod_{i=1}^{\varphi(m)} ar_i \equiv a^{\varphi(m)}\prod_{i=1}^{\varphi(m)} r_i ({\rm{mod }}\ m)
$$
同余式两侧约去 $\prod_{i=1}^{\varphi(m)} r_i$ 后得
$$
a^{\varphi(m)} \equiv 1({\rm{mod}}\ m)
$$
当 $m$ 为质数时 $\varphi(m)=m-1$ ，得到费马小定理 $a^{m-1}\equiv 1({\rm{mod}}\ m)$&lt;/p&gt;
&lt;h3&gt;扩展欧拉定理&lt;/h3&gt;
&lt;p&gt;$$
a^b=\left{ \begin{array}{l}
a^{b\ {\rm{mod}}\ \varphi(m)} &amp;amp; {\rm{gcd}}(a,m)=1 &amp;amp;({\rm{mod}}\ m)
\
a^b&amp;amp;b&amp;lt;\varphi(m),{\rm{gcd}}(a,m)\ne1 &amp;amp;({\rm{mod}}\ m)
\
a^{b\ {\rm{mod}}\ \varphi(m)+\varphi(m)} &amp;amp;b\ge\varphi(m),{\rm{gcd}}(a,m)\ne1&amp;amp;({\rm{mod}}\ m)
\end{array} \right.
$$&lt;/p&gt;
&lt;p&gt;计算 $a^b$ 时，若 $b$ 较小，直接跑一遍快速幂即可，否则先用扩展欧拉定理进行降幂再跑快速幂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于单独的 $b$ 来说，利用试除法比筛法更加优秀&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LL get_phi(LL n){
	LL res=n;
	for (LL i=2;i*i&amp;lt;=n;i++){
		if (n%i==0){
			res=res*(i-1)/i;
			while (n%i==0)
				n/=i;
		}
	}
	if (n&amp;gt;1) res=res*(n-1)/n;
	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对 $b$ 进行降幂操作，因为 $a^{\varphi(m)} \equiv 1\to a^{b\ {\rm{mod}}\ \varphi(m)}\equiv a^{b\ {\rm{mod}}\ \varphi(m)+\varphi(m)}({\rm{mod}}\ m)$ ，所以不需要单独判断&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LL depow(LL phi,string b){
	LL res=0;
	bool f=0;//判断b和phi_m的大小关系
	for (auto c:b){
		res=res*10+(c-&apos;0&apos;);
		if (res&amp;gt;=phi) f=1,res%=phi;
	}
	if (f) res+=phi;//如果b&amp;gt;phi_m则需要加上phi_m
	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以洛谷P5091为例：https://www.luogu.com.cn/problem/P5091、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LL ksm(LL a,LL b,LL p){
	LL res=1;
	while (b){
		if (b&amp;amp;1) res=res*a%p;
		a=a*a%p;
		b&amp;gt;&amp;gt;=1;
	}
	return res;
}

LL get_phi(LL n){
	LL res=n;
	for (LL i=2;i*i&amp;lt;=n;i++){
		if (n%i==0){
			res=res*(i-1)/i;
			while (n%i==0)
				n/=i;
		}
	}
	if (n&amp;gt;1) res=res*(n-1)/n;
	return res;
}

LL depow(LL phi,string b){
	LL res=0;
	bool f=0;
	for (auto c:b){
		res=res*10+(c-&apos;0&apos;);
		if (res&amp;gt;=phi) f=1,res%=phi;
	}
	if (f) res+=phi;
	return res;
}

void solve(){
	LL a,m;
	string b;
	cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;m&amp;gt;&amp;gt;b;
	cout&amp;lt;&amp;lt;ksm(a,depow(get_phi(m),b),m)&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>筛法求约数个数、约数和定理</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-05-21-%E7%AD%9B%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-05-21-%E7%AD%9B%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/</guid><description>约数个数的计算以及相关定理</description><pubDate>Wed, 21 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;约数&lt;/h3&gt;
&lt;p&gt;定义：$a|b$ 表示 $a$ 整除于 $b$ （$b$ 能被 $a$ 整除），$b$ 为 $a$ 的倍数，$a$ 为 $b$ 的约数&lt;/p&gt;
&lt;p&gt;规定 &lt;strong&gt;$0$ 是所有非 $0$ 整数的倍数&lt;/strong&gt;，且对于非 $0$ 整数 $b$ ，$b$ 的约数只有&lt;strong&gt;有限个&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于非 $0$ 整数 $b$ ，$\pm1,\pm b$ 是 $b$ 的平凡约数（当 $b=\pm1$ 时，$b$ 只有两个平凡约数），$b$ 的其他约数称为真约数（非平凡约数）&lt;/p&gt;
&lt;p&gt;满足性质如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数 $b\ne0$，给定的 $d$ 在遍历 $b$ 的全体约数时，$\frac{b}{d}$ 也遍历 $b$ 的全体约数&lt;/li&gt;
&lt;li&gt;整数 $b&amp;gt;0$，给定的 $d$ 在遍历 $b$ 的全体正约数时，$\frac{b}{d}$ 也遍历 $b$ 的全体正约数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一般讨论中，我们约定的约数总是指正约数&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;约数个数定理&lt;/h3&gt;
&lt;p&gt;对于整数 $n&amp;gt;1$ ，根据唯一分解定理其可以被分解为若干个质因子的连乘积，表示为
$$
n=\prod_{i=1}^{s} p_i^{\alpha &lt;em&gt;i}=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdots p_s^{\alpha_s}
$$
那么它的约数个数 $d(n)$ 可以通过下面的表达式得出
$$
d(n)=\prod&lt;/em&gt;{i=1}^s (\alpha_i+1)
$$
简单证明如下：&lt;/p&gt;
&lt;p&gt;$p_i^{\alpha_i}$ 的因子有 $p_1^0,p_i^1,\cdots,p_i^{\alpha_i}$ 共计 $\alpha_i+1$ 个，递推地计算 $p_{i+1}^{\alpha_{i+1}}$ 及所有项，根据乘法原理得出 $d(n)=\prod_{i=1}^s (\alpha_i+1)$&lt;/p&gt;
&lt;p&gt;（若 $p_i^a,p_j^b$ 都是 $n$ 的因子，那么 $p_i^a*p_j^b$ 也是 $n$ 的因子）&lt;/p&gt;
&lt;h3&gt;线性筛法求约数个数&lt;/h3&gt;
&lt;p&gt;筛除合数时，分别考虑两种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;枚举的 $i$ 能被 $p_j$ 整除，则 $p_j$ 一定是 $m$ 的最小质因子，于是递推积累最小质因子的次数 $\alpha_m=\alpha_i+1$&lt;/p&gt;
&lt;p&gt;因为 $d(i)=(\alpha_i+1)&lt;em&gt;\cdots,d(m)=(\alpha_m+1)&lt;/em&gt;\cdots$ 所以 $d(m)$ 由下式计算得出
$$
d(m)=d(i)&lt;em&gt;\frac{1}{\alpha_m}&lt;/em&gt;(\alpha_m+1)
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若 $i$ 不能被 $p_j$ 整除，则 $i$ 不包含质因子 $p_j$，那么 $\alpha_m=1,d(m)=d(i)&lt;em&gt;(\alpha_m+1)=2&lt;/em&gt;d(i)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int p[N],cnt;
bool vis[N];
int a[N],d[N];//a用来记录i的质因子的次数alpha_i，d用来记录i的约数个数

void get_d(int n){
	d[1]=1;//定义1的约数个数为1
	for (int i=2;i&amp;lt;=n;i++){
		if (!vis[i]){//如果当前i为质数
			p[++cnt]=i;//存进p数组
			a[i]=1;//质数的最小质因子是它本身，且次数为1
			d[i]=2;//规定质数的约数个数为2
		}
		for (int j=1;i*p[j]&amp;lt;=n;j++){//筛除以i为最小质因子的合数
			int m=i*p[j];
			vis[m]=1;//标记合数
			if (i%p[j]==0){//确定只被最小质因子筛除
				a[m]=a[i]+1;
				d[m]=d[i]/a[m]*(a[m]+1);
				break;
			}else{
				a[m]=1;
				d[m]=d[i]*2;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;约数和定理&lt;/h3&gt;
&lt;p&gt;有 $n=\prod_{i=1}^sp_i^{\alpha_i}$ ，记 $n$ 的约数和为 $f(n)$ ，满足
$$
f(n)=\prod_{i=1}^s \sum_{j=0}^{\alpha_i} p_i^j
$$
简单证明如下：&lt;/p&gt;
&lt;p&gt;通过约数个数定理可知，$n$ 的任意一个约数都是在每一个质因子 $p_1^{\alpha_1},p_2^{\alpha_2},\cdots,p_s^{\alpha_s}$ 中，选出这个质因子 $p_i^{\alpha_i}$ 的任意一个约数乘法组合而成&lt;/p&gt;
&lt;p&gt;那么，不同的选法共有 $\prod_{i=1}^s (\alpha_i+1)$ 种，即约数个数&lt;/p&gt;
&lt;p&gt;那么，它们的和即为
$$
(p_1^0+p_1^1+\cdots+p_1^{\alpha_1})\times(p_2^0+p_1^2+\cdots+p_2^{\alpha_2})\times\cdots\times(p_s^0+p_s^1+\cdots+p_s^{\alpha_s})
$$
可以看作分别计算出了每个质因子的约数的每种情况，再相加&lt;/p&gt;
&lt;h3&gt;线性筛法求约数和&lt;/h3&gt;
&lt;p&gt;需要记录每个 $i$ 的最小质因子贡献的累加和，记为 $g_i$，其中 $p_{\gamma}$ 表示 $i$ 的最小质因子
$$
g_i=\sum_{i=0}^{\alpha_i} p_{\gamma}^i
$$
筛除合数时，分别考虑两种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;枚举的 $i$ 能被 $p_j$ 整除，则 $p_j$ 一定是 $m$ 的最小质因子，分别计算 $g_i,g_m$&lt;/p&gt;
&lt;p&gt;$$
g_i=\sum_{i=0}^{\alpha_j}p_j^i \ \ ,\ \  g_m=\sum_{i=0}^{\alpha_j+1}p_j^i=g_i&lt;em&gt;p_j+p_j^0
$$
那么就能从 $f_i$ 递推到 $f_m$
$$
f_i=g_i&lt;/em&gt;\prod_{j}^{j\ne i} g_j\ \ ,\ \ f_m=g_m*\prod_j^{j\ne i} g_j=\frac{f_i}{g_i}*g_m
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若 $i$ 不能被 $p_j$ 整除，则 $i$ 不包含质因子 $p_j$
$$
g_m=1+p_j\ \ ,\ \ f_m=g_m*f_i
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int p[N],cnt;
bool vis[N];
int g[N],f[N];//g记录i的最小质因子贡献的累加和，f表示i的约数和

void get_f(int n){
	g[1]=f[1]=1;
	for (int i=2;i&amp;lt;=n;i++){
		if (!vis[i]){
			p[++cnt]=i;
			g[i]=f[i]=i+1;
		}
		for (int j=1;i*p[j]&amp;lt;=n;j++){
			int m=i*p[j];
			vis[m]=1;
			if (i%p[j]==0){
				g[m]=g[i]*p[j]+1;
				f[m]=f[i]/g[i]*g[m];
				break;
			}else{
				g[m]=p[j]+1;
				f[m]=f[i]*g[m];
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>同余式、乘法逆元、费马小定理</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-09-%E5%90%8C%E4%BD%99%E5%BC%8F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-09-%E5%90%8C%E4%BD%99%E5%BC%8F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</guid><description>同余式的相关概念和模意义下的计算</description><pubDate>Sun, 09 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;同余式&lt;/h3&gt;
&lt;p&gt;如果两个整数 $a,b$ 对 $m$ 取余的余数相同，则 $a,b$ 模 $m$ 同余，记作 &lt;strong&gt;$a\equiv b(mod\ m)$&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;乘法逆元&lt;/h3&gt;
&lt;p&gt;若两个整数 $a,b$ 互质，且满足同余方程 $a\cdot x\equiv 1(mod\ b)$ ，则定义 $x$ 为 $a\ mod\ b$ 的乘法逆元，记作 $a^{-1}$&lt;/p&gt;
&lt;p&gt;例如：$4x\equiv1(mod\ 5)$ 可以解得 $x=4,9,14\cdots(4+5\lambda)$ ，一般取小于 $b$ 的乘法逆元方程的&lt;strong&gt;特解&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;费马小定理&lt;/h3&gt;
&lt;p&gt;若 $p$ 为质数，且 $a,p$ 互质，则满足同余式 $a^{p-1}\equiv1(mod\ p)$ ，例如：$2^{3-1}\equiv1(mod\ 3)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;证明如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	首先存在一个质数为 $p$ ，根据&lt;strong&gt;欧拉函数&lt;/strong&gt;的性质，与它互质的数即为 $[1,p-1]$ 其中的元素组成的序列，记为：
$$
A={1,2,3,\cdots,p-1}
$$
​	需要证明以下&lt;strong&gt;同余式&lt;/strong&gt;成立：	
$$
\prod_{i=1}^{p-1} (a\times A_i)\equiv \prod_{i=1}^{p-1}A_i(mod\ p)\impliedby a^{p-1}\times \prod_{i=1}^{p-1} A_i\equiv \prod_{i=1}^{p-1}A_i(mod \ p)
$$
​	即说明每一个 $a\times A_i(mod \ p)$ 的余数都是&lt;strong&gt;互不相同&lt;/strong&gt;的，推导过程有：&lt;/p&gt;
&lt;p&gt;​	假设 $a\times A_i(mod\ p),a\times A_j(mod\ p)$ 的余数&lt;strong&gt;相同&lt;/strong&gt;且为 $r$ ，则满足 $a\times A_i=xp+r,a\times A_j=yp+r$
$$
\implies a(A_i-A_j)=(x-y)p
$$
​	&lt;strong&gt;若 $r$ 存在&lt;/strong&gt;，则 $a(A_i-A_j)$ 一定不为 $p$ 的倍数，&lt;strong&gt;当 $A_i\ne A_j $ 时&lt;/strong&gt; $(x-y)p$  一定为 $p$ 的倍数，则等式不成立&lt;/p&gt;
&lt;p&gt;​	反之就说明了每一个 $a\times A_i(mod \ p)$ 的余数都是互不相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;又因为 $a\times A_i(mod\ p)&amp;lt;p$ 恒成立，所以与 $A_i(mod \ p)$ 的余数集合必然相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;则：
$$
a^{p-1}\times \prod_{i=1}^{p-1} A_i\equiv \prod_{i=1}^{p-1}A_i(mod \ p)
$$
两侧消去 $\prod_{i=1}^{p-1}A_i$ 后得到方程
$$
a^{p-1}\equiv 1 (mod\ p)
$$
例如：$p=5,A={ 1,2,3,4},a=2$，那么 $a\times A={2,4,6,8},a\times A\ %\ p={2,4,1,3}=A\ %\ p={1,2,3,4}$&lt;/p&gt;
&lt;h3&gt;快速幂加速计算乘法逆元&lt;/h3&gt;
&lt;p&gt;给定两个整数 $a,p$ ，$p$ 为质数，求 $a$ 模 $p$ 的乘法逆元&lt;/p&gt;
&lt;p&gt;根据费马小定理有：$a^{p-1}\equiv1(mod \ p)\iff a\times a^{p-2}\equiv1(mod\ p)$，则 $a^{p-2}$ 即为 $a$ 模 $p$ 的乘法逆元&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;p;
cout&amp;lt;&amp;lt;quickpow(a,p-2,p);//调用快速幂计算a^(p-2)，过程中仍然需要对p取余

long long quickpow(long long a,long long b,long long p){
	long long res=1;
	while (b){
		if (b&amp;amp;1) res=res*a%p;
		a=a*a%p;
		b&amp;gt;&amp;gt;=1;
	}
	return res;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>整除分块</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</guid><description>暴力区间计算的一种优化方式</description><pubDate>Wed, 05 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;整除分块/数论分块&lt;/h3&gt;
&lt;p&gt;快速计算一群向下取整的和式，打包同时计算拥有相同的 $\lfloor\frac{n}{i}\rfloor$ 的分式，时间复杂度可以优化到 $O(\sqrt n)$&lt;/p&gt;
&lt;p&gt;例如需要计算
$$
\sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor
$$
依次写出拥有相同 $\lfloor\frac{n}{i}\rfloor$ 的分式
$$
\begin{array}{c|c|c|c|c|c|c|c|c|cc}&lt;/p&gt;
&lt;p&gt;i&amp;amp;1&amp;amp;2&amp;amp;3&amp;amp;4&amp;amp; 5&amp;amp; 6\ 7&amp;amp;8\ 9\ 10&amp;amp;11\cdots21
\\hline
\lfloor\frac{n}{i}\rfloor&amp;amp;21&amp;amp;10&amp;amp;7&amp;amp;5&amp;amp;4&amp;amp;3&amp;amp;2&amp;amp;1
\end{array}
$$
分块存在两种性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 $\lfloor\frac{n}{i}\rfloor$ 分块的数量 $\le2\lfloor \sqrt n\rfloor$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以 $\sqrt n$ 为分界线&lt;/strong&gt;，$i\le \sqrt n$ 时，$\lfloor\frac{n}{i}\rfloor$ 有 $\lfloor\sqrt n\rfloor$ 种取值，$i&amp;gt; \sqrt n$ 时，$\lfloor\frac{n}{i}\rfloor$ &lt;strong&gt;至多&lt;/strong&gt;有 $\lfloor\sqrt n\rfloor$ 种取值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$i$ 所在分块的右端点为 $rfub$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
rfub=\lfloor \frac{n}{\lfloor \frac{n}{i}\rfloor}\rfloor
$$&lt;/p&gt;
&lt;p&gt;设 $i$ 所在分块的 $\lfloor\frac{n}{i}\rfloor$ 为 $k$ ，则有以下推理
$$
k\le \frac{n}{i} \implies \frac{n}{k} \ge \frac{n}{\lfloor\frac{n}{i}\rfloor}\implies
\lfloor \frac{n}{k}\rfloor \ge \lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor
$$
又因为
$$
\lfloor \frac{n}{k}\rfloor \ge \lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor=\lfloor i\rfloor=i
$$
那么 $i$ 所在分块的区间为
$$
\lfloor\frac{n}{\lfloor k_{i-1} \rfloor}\rfloor\le i \le \lfloor\frac{n}{\lfloor k_{i} \rfloor}\rfloor=\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor
$$&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;综合以上两个性质，可以推广公式有&lt;/strong&gt;
$$
\sum_{i=1}^n f(i)\lfloor\frac{n}{i}\rfloor
$$
首先通过&lt;strong&gt;前缀和预处理 $f(i)$&lt;/strong&gt;
$$
s(i)=\sum_{j=1}^i f(j)
$$
那么答案就可以表示为
$$
\sum_{i=1}^n f(i)\lfloor\frac{n}{i}\rfloor=\sum_i [s(r)-s(l-1)]\cdot\lfloor\frac{n}{i}\rfloor
$$&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;以计算 $\sum_{i=1}^{n} k\ % \ i$ 为例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和式可以变形为
$$
\sum_{i=1}^{n} k\ % \ i\implies \sum_{i=1}^{n} k-i*\lfloor\frac{k}{i}\rfloor=n&lt;em&gt;k-\sum_{i=1}^{n}i&lt;/em&gt;\lfloor\frac{k}{i}\rfloor
$$
代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long long n,k;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;
long long sum=n*k;
long long l,r;
for (l=1;l&amp;lt;=n;l=r+1){//计算分块左边界
	if (k/l==0) break;//如果l大于k，那么之后的项都为0，提前中断
	r=min(k/(k/l),n);//如果计算的右边界超出n，那么就到n为止
	sum-=(k/l)*(r-l+1)*(l+r)/2;//等差数列计算
}
cout&amp;lt;&amp;lt;sum;
return 0;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>筛法求欧拉函数</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-02-05-%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</guid><description>欧拉函数的定义以及计算的方式</description><pubDate>Wed, 05 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;hr /&gt;
&lt;h3&gt;欧拉函数&lt;/h3&gt;
&lt;p&gt;$1$ ~ $n$ 中与 $n$ 互质的数的个数叫做&lt;strong&gt;欧拉函数&lt;/strong&gt;，记作 $\varphi (n)$&lt;/p&gt;
&lt;p&gt;有性质如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在质数 $p$ ，则 $\varphi(p)=p-1$&lt;/li&gt;
&lt;li&gt;存在质数 $p$ ，则 $\varphi(p^k)=(p-1)p^{k-1}$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;于是可以推出欧拉函数的计算公式，根据惟一分解定理有
$$
n=\prod_{i=1}^sp_i^{\alpha_i}=p_1^{\alpha_1}p_2^{\alpha_2} \dots p_s^{\alpha_s}
$$
于是欧拉函数可以写为
$$
\varphi(n)=\prod_{i=1}^s\varphi(p_i^{s_i})&lt;/h1&gt;
&lt;p&gt;\prod_{i=1}^s(p_i-1)p_i^{\alpha_i-1}
$$
$$
\Rightarrow\varphi(n)=\prod_{i=1}^sp_i^{\alpha_i}(1-\frac{1}{p_i})
=\prod_{i=1}^sp_i^{\alpha_i}\times \prod_{i=1}^s(1-\frac{1}{p_i})
$$
整理后得到
$$
\varphi(n)=n\times\prod_{i=1}^s\frac{p_i-1}{p_i}=n\times
\frac{p_1-1}{p_1}\times\frac{p_2-1}{p_2}\times\dots\times\frac{p_s-1}{p_s}
$$
&lt;strong&gt;观察上式可以发现欧拉函数只和 $n$ 与它的质因子有关&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;试除法求欧拉函数&lt;/h3&gt;
&lt;p&gt;从小到大枚举 $\sqrt{n}$ 的质因子，计算 $\frac{p_i-1}{p_i}$ ，然后在 $n$ 中&lt;strong&gt;除掉这个质因子的所有贡献&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long long get_phi(int n){
	long long res = n;
	for (long long i = 2; i * i &amp;lt;= n; i++){
		if (n % i == 0){//判断i是否为n的质因子
			res = res * (i - 1) / i;//计算欧拉函数的部分
			while (n % i == 0) //把n中的这个质因子除干净
				n /= i;
		}
	}
	if (n &amp;gt; 1) res = res * (n - 1) / n;/如果最后剩余的n大于1，那么n就是最后的一个最大质因子
	return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if (n &amp;gt; 1) res = res * (n - 1) / n;&lt;/code&gt; 加上这句判断的原因是：&lt;strong&gt;一个整数 $n$ 最多仅有一个超过 $\sqrt n$ 的质因子&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;筛法求欧拉函数&lt;/h3&gt;
&lt;p&gt;通过线性筛法计算从 $1$ ~ $n$ 之间每个数的欧拉函数，以下是欧拉函数的另一个性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若有 $gcd(m,n)=1$ （$m,n$互质），则 $\varphi(mn)=\varphi(m)\times\varphi(n)$&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int p[N], vis[N], cnt;
int phi[N];

void get_phi(int n){
	for (int i = 2, i &amp;lt;= n; i++){
		if (!vis[i]){
			p[cnt++] = i;
			phi[i] = i - 1;
		}
		for (int j = 0; i * p[j] &amp;lt;= n; j++){
			int m = i * p[j];
			vis[m] = 1;
			if (i % p[j] == 0){
				phi[m] = p[j] * phi[i];
				break;
			}
			else
				phi[m] = (p[j] - 1) * phi[i];
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果枚举的 $i$ 为质数，那么 $\varphi(i)=i-1$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//vis[i]==0
phi[i] = i - 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;枚举的 $i$ 为合数（此时的 $i$ 已被之前的质因子筛到过），那么存在两种情况，&lt;strong&gt;可以向后递推合数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;筛到的 $m$ 可以写作 $i*p_j$ ，如果 $i$ 能被 $p_j$ 整除，&lt;strong&gt;说明 $\varphi(m)=\varphi(i)$（$i$ 存在 $m$ 的所有质因子）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 $i$ 不能被 $p_j$ 整除，说明 $i,p_j$ 互质，那么 $\varphi(m)=\varphi(i)*\varphi(p_j)$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果只需要求单个数的欧拉函数，试除法比筛法更加优秀&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>质数筛</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-01-02-%E8%B4%A8%E6%95%B0%E7%AD%9B/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2025-01-02-%E8%B4%A8%E6%95%B0%E7%AD%9B/</guid><description>选取质数的多种方式</description><pubDate>Thu, 02 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;hr /&gt;
&lt;h3&gt;试除法判定质数&lt;/h3&gt;
&lt;p&gt;暴力做法：枚举 $2$ ~ $n-1$ 的所有数，判断能否将 $n$ 整除，如果存在一个数能把 $n$ 整数，说明 $n$ 不是质数&lt;/p&gt;
&lt;p&gt;实际上只需要枚举到 $\sqrt{n}$ 即可，如果 $a$ 是 $n$ 的约数，那么 $\frac{n}{a}$ 也是 $n$ 的约数，我们只需要检验 $min(a,\frac{n}{a})$ 即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool is_prime(int x){
	if (x == 1) return 0;//1不是质数
	for (long long i = 2; i &amp;lt;= sqrt(x); i++)//从小到大枚举
		if (x % i == 0) return 0;//如果能整除，立即返回非质数
	return 1;//返回是质数
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的计算中，&lt;code&gt;i &amp;lt;= sqrt(x)&lt;/code&gt; 的操作可以优化为 &lt;code&gt;i * i &amp;lt;= x&lt;/code&gt; 或 &lt;code&gt;i &amp;lt;= x / i&lt;/code&gt; ，得到常数级的优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不难看出对于判断 $n$ 而言，试除法判断质数的时间复杂度为 $O(\sqrt{n})$&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;埃拉托斯特尼筛法&lt;/h3&gt;
&lt;p&gt;这是一种在给定区间内有效筛选素数的方式，原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 $2$ 开始枚举每一个数，直到到达给定的界限&lt;/li&gt;
&lt;li&gt;对每一个枚举的数都判断一次状态&lt;/li&gt;
&lt;li&gt;枚举&lt;strong&gt;当前质数的倍数&lt;/strong&gt;，他们必然是合数，更改状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后每个数都存在一个状态，&lt;strong&gt;要么被标记为合数，要么被标记为质数&lt;/strong&gt;，这就完成了筛选素数的过程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool st[N];//状态数组，合数被标记为 1，初始化时都为 0
int prime_mem[N];//记录素数
int cnt;//素数个数

void Eratosthens(int n){
	for (long long i = 2; i &amp;lt;= n; i++){//从小到大枚举
		if (!st[i]){//如果这个数是素数
			prime_mem[++cnt] = i;//素数个数加 1，并记录
			for (long long j = i * i; j &amp;lt;= n; j += i)//从小到大枚举素数的倍数
				st[j] = 1;//标记素数
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;for (long long j = i * i; j &amp;lt;= n; j += i)&lt;/code&gt; 从 &lt;code&gt;i * i&lt;/code&gt; 开始标记合数，&lt;strong&gt;这是因为小于 &lt;code&gt;i * i&lt;/code&gt; 的合数在之前已经被标记过了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;证明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设 $k &amp;lt; i\quad k\in N^+$，则 $ki $ 为 $i$ 的倍数，满足 $ki&amp;lt;i^2$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
ki&amp;lt;i^2 \iff k&amp;lt;i
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在质数$p$， $p&amp;lt;i$，$p$ 标记了它的倍数 $kp$ ，就有&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
p\times k=p \iff k=1
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于 $k&amp;lt;i$ ，所以下述不等式成立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
p\times k&amp;lt;p\times i&amp;lt;i^2 \iff p&amp;lt;i,k&amp;lt;i
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以任意的小于 $i^2$ 的合数，都已经被小于 $i$ 的一个素数 $p$ 标记过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然，&lt;strong&gt;根据算数基本定理，要找到 $n$ 以内的所有质数，只需要对不超过 $\sqrt{n}$ 的素数进行筛除即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (long long i = 2; i &amp;lt;= n; i++)&lt;/code&gt; $\rightarrow$ &lt;code&gt;for (long long i = 2; i * i &amp;lt;= n; i++)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种筛法的时间复杂度在 $O(n\log\log n)$ ，近乎于 $O(n)$&lt;/p&gt;
&lt;h3&gt;线性筛法/欧拉筛法&lt;/h3&gt;
&lt;p&gt;对于上面的埃拉托斯特尼筛法，过程中会对一个合数重复标记多次，通过线性筛法，可以做到让一个合数只被标记一次&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么时间复杂度就能降到 $O(n)$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;合数总是可以分解为多个质数的积&lt;/strong&gt;，（整数惟一分解定理）&lt;/li&gt;
&lt;li&gt;使筛掉的方法唯一，每次通过&lt;strong&gt;合数的最小质因子&lt;/strong&gt;筛掉&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;bool st[N];//状态数组，合数被标记为 1，初始化时都为 0
int prime_mem[N];//记录素数
int cnt;//素数个数

void Euler(int n){
	for (long long i = 2; i &amp;lt;= n; i++){
		if (!st[i]) prime_mem[++cnt] = i;
		for (long long j = 1; i * prime_mem[j] &amp;lt;= n; j++){
			st[i * prime_mem[j]] = 1;
			if (i % prime_mem[j] == 0) break;//保证只被最小质因子筛除
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$i$ 为质数，最多枚举到自身中断，即 $i^2\ %\   i=0$ 。$i$ 为合数，&lt;strong&gt;最多枚举到最小质因子 $p$ 结束&lt;/strong&gt;，即 $i*p\ %\ i=0$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中的 &lt;code&gt;st[i * prime_mem[j]] = 1;&lt;/code&gt; 做到了具体的筛除过程&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>欧几里得算法、惟一分解定理</title><link>https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2024-12-19-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%83%9F%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/</link><guid isPermaLink="true">https://mizuki.mysqil.com/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/2024-12-19-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%83%9F%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/</guid><description>一种求最大公约数算法和质因数分解</description><pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;hr /&gt;
&lt;h3&gt;欧几里得算法（辗转相除法）求最大公约数GCD&lt;/h3&gt;
&lt;p&gt;有两个整数 $a,b(a&amp;gt;b)$ ，记它们的最大公约数为 $gcd(a,b)$，对于任意的 $a,b\ne 0$ 满足等式 ：
$$
gcd(a,b)=gcd(b,a% b)
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;充分性证明：&lt;/p&gt;
&lt;p&gt;设 $d$ 为 $a,b$ 的最大公约数，那么有 $d\mid a$ 和 $d\mid b$ 成立，组合出 $d\mid (a-kb),\ (k\in N)$ 也成立，其中 $a-kb=a%b$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必要性证明：&lt;/p&gt;
&lt;p&gt;设 $d$ 为 $a,a% b$ 的最大公约数，那么有 $d\mid a$ 和 $d\mid (a-kb),\ (k\in N)$ 成立，同样可以组合出 $d\mid b$ 成立&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序设计中可以递归求解，递归出口为 $a,b=0$ ，其中不为 $0$ 的项即为最大公约数（$a&amp;gt;b$）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int gcd(int a, int b){
	if (b == 0) return a;
	return gcd(b, a % b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;复杂度分析：&lt;/p&gt;
&lt;p&gt;对 $a$ 取 $b$ 的模时，至少可以将 $a$ 缩小到 $a/2$ ，即 $a% b \le a/2$ ，证明如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$b&amp;lt; a/2$ 时，$a% b&amp;lt;b&amp;lt; a/2$&lt;/li&gt;
&lt;li&gt;$b&amp;gt;a/2$ 时，$a%b=a-b\le a/2$&lt;/li&gt;
&lt;li&gt;$b=a/2$ 时，$a% b=0&amp;lt;a/2$ （特殊状况，$b$ 为 $a$ 因子）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;最小公倍数LCM&lt;/h3&gt;
&lt;p&gt;有两个整数 $a,b(a,b\ne 0)$ ，记它们的最小公倍数为 $lcm(a,b)$，对于任意的 $a,b\ne 0$ 满足等式 ：
$$
lcm(a,b)=\frac{a\times b}{gcd(a,b)}
$$&lt;/p&gt;
&lt;p&gt;计算LCM需要先计算出GCD，采用&lt;strong&gt;先除后乘防止溢出&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int lcm(int a, int b){
		return a / gcd(a, b) * b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;算数基本定理（整数惟一分解定理）&lt;/h3&gt;
&lt;p&gt;对于任意的一个正整数 $n$ ，有且仅有一种由&lt;strong&gt;质数的乘积&lt;/strong&gt;所表达的方式
$$
n=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdot\cdot\cdot p_s^{\alpha_s}
\quad \quad
p_1&amp;lt;p_2&amp;lt;\cdot \cdot\cdot&amp;lt;p_s
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$n$  至多含有一个大于 $\sqrt{n}$ 的质因子&lt;/p&gt;
&lt;p&gt;根据上述的表达方式可以反推，若有两个大于 $\sqrt{n}$ 的质因子，它们的乘积一定大于了 $n$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;证明LCM表达式&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;设 ：
$$
a=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdot\cdot\cdot p_s^{\alpha_s}
\
b=p_1^{\beta_1}\cdot p_2^{\beta_2}\cdot\cdot\cdot p_s^{\beta_s}
$$
那么 $gcd(a,b)$ 与 $lcm(a,b)$ 可表示为
$$
gcd(a,b)=p_1^{min(\alpha_1,\beta_1)}\cdot p_2^{min(\alpha_2,\beta_2)}\cdot\cdot\cdot p_s^{\min(\alpha_s,\beta_s)}
$$
$$
lcm(a,b)=p_1^{max(\alpha_1,\beta_1)}\cdot p_2^{max(\alpha_2,\beta_2)}\cdot\cdot\cdot p_s^{\max(\alpha_s,\beta_s)}
$$
因为满足以下的约束条件
$$
min(\alpha_i,\beta_i)+max(\alpha_i,\beta_i)=\alpha_i+\beta_i
$$
所以有
$$
gcd(a,b)\times lcm(a,b) =p_1^{\alpha_1+\beta_1}\cdot p_2^{\alpha_2+\beta_2}\cdot\cdot\cdot p_s^{\alpha_s+\beta_s}&lt;/h1&gt;
&lt;p&gt;a\times b
$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item></channel></rss>